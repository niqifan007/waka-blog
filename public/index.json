[{"categories":null,"content":"\u003cno value\u003e's friends","date":"2023-08-01","objectID":"/friends/","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"\r","date":"2023-08-01","objectID":"/friends/:0:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"Base info - nickname: Lruihao avatar: https://lruihao.cn/images/avatar.jpg url: https://lruihao.cn description: Lruihao's Note ","date":"2023-08-01","objectID":"/friends/:1:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"Friendly Reminder Notice\rIf you want to exchange link, please leave a comment in the above format. (personal non-commercial blogs / websites only)  Website failure, stop maintenance and improper content may be unlinked! Those websites that do not respect other people’s labor achievements, reprint without source, or malicious acts, please do not come to exchange. ","date":"2023-08-01","objectID":"/friends/:2:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":["Docker"],"content":"Docker Hub 镜像加速器","date":"2023-07-25","objectID":"/dockerhub/","tags":["Docker"],"title":"Docker Hub 镜像加速器汇总","uri":"/dockerhub/"},{"categories":["Docker"],"content":"Docker Hub 镜像加速器 国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务。 Dockerized 实践 https://github.com/y0ngb1n/dockerized ","date":"2023-07-25","objectID":"/dockerhub/:0:0","tags":["Docker"],"title":"Docker Hub 镜像加速器汇总","uri":"/dockerhub/"},{"categories":["Docker"],"content":"配置加速地址 Ubuntu 16.04+、Debian 8+、CentOS 7+ 创建或修改 /etc/docker/daemon.json： sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [ \"https://docker.m.daocloud.io\", \"https://dockerproxy.com\", \"https://docker.mirrors.ustc.edu.cn\", \"https://docker.nju.edu.cn\" ] } EOF sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2023-07-25","objectID":"/dockerhub/:1:0","tags":["Docker"],"title":"Docker Hub 镜像加速器汇总","uri":"/dockerhub/"},{"categories":["Docker"],"content":"Docker Hub 镜像加速器列表 镜像加速器 镜像加速器地址 专属加速器？ 其它加速？ Docker 中国官方镜像 https://registry.docker-cn.com Docker Hub（已关闭） DaoCloud 镜像站 https://docker.m.daocloud.io Docker Hub、GCR、K8S、GHCR、Quay、NVCR 等 Azure 中国镜像 https://dockerhub.azk8s.cn 仅供内部访问 Docker Hub、GCR、Quay 科大镜像站 https://docker.mirrors.ustc.edu.cn 仅供内部访问 Docker Hub、GCR、Quay 阿里云 https://\u003cyour_code\u003e.mirror.aliyuncs.com 需登录，系统分配 Docker Hub 七牛云 https://reg-mirror.qiniu.com Docker Hub、GCR、Quay 网易云 https://hub-mirror.c.163.com Docker Hub 腾讯云 https://mirror.ccs.tencentyun.com 仅供内部访问 Docker Hub Docker 镜像代理 https://dockerproxy.com Docker Hub、GCR、K8S、GHCR 百度云 https://mirror.baidubce.com Docker Hub 南京大学镜像站 https://docker.nju.edu.cn Docker Hub、GCR、GHCR、Quay、NVCR 等 上海交大镜像站 https://docker.mirrors.sjtug.sjtu.edu.cn Docker Hub、GCR 等 ⚠️ 以下镜像站存在未同步最新源镜像问题，请按需选用 阿里云 ","date":"2023-07-25","objectID":"/dockerhub/:2:0","tags":["Docker"],"title":"Docker Hub 镜像加速器汇总","uri":"/dockerhub/"},{"categories":["Docker"],"content":"检查加速器是否生效 命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功。 Registry Mirrors: [...] https://docker.m.daocloud.io ","date":"2023-07-25","objectID":"/dockerhub/:3:0","tags":["Docker"],"title":"Docker Hub 镜像加速器汇总","uri":"/dockerhub/"},{"categories":["Docker"],"content":"Docker Hub 镜像测速 使用镜像前后，可使用 time 统计所花费的总时间。测速前先移除本地的镜像！ $ docker rmi node:latest $ time docker pull node:latest Pulling repository node [...] real 1m14.078s user 0m0.176s sys 0m0.120s ","date":"2023-07-25","objectID":"/dockerhub/:4:0","tags":["Docker"],"title":"Docker Hub 镜像加速器汇总","uri":"/dockerhub/"},{"categories":["Docker"],"content":"参考链接 https://docs.docker.com/registry/recipes/mirror/ https://github.com/yeasy/docker_practice/blob/master/install/mirror.md https://github.com/moby/moby/blob/d409b05970e686993e343d226fae5b463d872082/docs/articles/registry_mirror.md https://www.fengbohello.top/archives/docker-registry-mirror https://www.ilanni.com/?p=14534 https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy https://moelove.info/2020/09/20/突破-DockerHub-限制全镜像加速服务/ ","date":"2023-07-25","objectID":"/dockerhub/:5:0","tags":["Docker"],"title":"Docker Hub 镜像加速器汇总","uri":"/dockerhub/"},{"categories":["机器学习"],"content":"了解LSTM神经网络","date":"2023-04-24","objectID":"/lstm_2/","tags":["LSTM","神经网络","机器学习"],"title":"了解LSTM神经网络","uri":"/lstm_2/"},{"categories":["机器学习"],"content":"循环神经网络 人类不会每一秒都从头开始思考。当你阅读这篇文章时，你会根据你对前面单词的理解来理解每个单词。你不会扔掉所有东西，然后重新开始思考。你的思想有坚持。 传统的神经网络无法做到这一点，这似乎是一个主要缺点。例如，假设您想对电影中每一点发生的事件类型进行分类。目前尚不清楚传统的神经网络如何利用其对电影中先前事件的推理来通知后来的事件。 递归神经网络解决了这个问题。它们是带有循环的网络，允许信息持续存在。 递归神经网络有循环。 在上图中，一大块神经网络，$A$, 查看一些输入$x_t$并输出一个值$h_t$. 循环允许信息从网络的一个步骤传递到下一个步骤。 这些循环使递归神经网络看起来有点神秘。然而，如果你多想想，就会发现它们与普通的神经网络并没有什么不同。循环神经网络可以被认为是同一网络的多个副本，每个副本都将一条消息传递给后继者。考虑一下如果我们展开循环会发生什么： 展开的递归神经网络。 这种链状性质表明循环神经网络与序列和列表密切相关。它们是用于此类数据的神经网络的自然架构。 他们肯定被使用了！在过去的几年里，将 RNN 应用于各种问题取得了令人难以置信的成功：语音识别、语言建模、翻译、图像字幕……这个例子不胜枚举。关于 RNN 可以实现的惊人壮举，我将在 Andrej Karpathy 的优秀博客文章The Unreasonable Effectiveness of Recurrent Neural Networks中进行讨论。但他们真的很了不起。 这些成功的关键是使用“LSTM”，这是一种非常特殊的递归神经网络，对于许多任务，它比标准版本要好得多。几乎所有基于递归神经网络的令人兴奋的结果都是用它们实现的。本文将探讨这些 LSTM。 ","date":"2023-04-24","objectID":"/lstm_2/:1:0","tags":["LSTM","神经网络","机器学习"],"title":"了解LSTM神经网络","uri":"/lstm_2/"},{"categories":["机器学习"],"content":"长期依赖的问题 RNN 的吸引力之一是它们可能能够将以前的信息连接到当前的任务，例如使用以前的视频帧可能会告知对当前帧的理解。如果 RNN 可以做到这一点，它们将非常有用。但他们可以吗？这取决于。 有时，我们只需要查看最近的信息即可执行当前任务。例如，考虑一个语言模型试图根据前面的单词预测下一个单词。如果我们试图预测“the clouds are in the sky ”中的最后一个词，我们不需要任何进一步的上下文——很明显下一个词将是 sky。在这种情况下，相关信息和需要它的地方之间的差距很小，RNN 可以学习使用过去的信息。 但在某些情况下，我们需要更多上下文。考虑尝试预测文本“我在法国长大……我说一口流利的_法语_”中的最后一个词。最近的信息表明，下一个词可能是一种语言的名称，但如果我们想缩小哪种语言的范围，我们需要法国的上下文，从更远的地方。相关信息和需要它的点之间的差距变得非常大是完全有可能的。 不幸的是，随着差距的扩大，RNN 变得无法学习连接信息。 理论上，RNN 绝对有能力处理这种“长期依赖”。人类可以仔细地为他们挑选参数来解决这种形式的玩具问题。遗憾的是，在实践中，RNN 似乎无法学习它们。Hochreiter (1991) [German]和Bengio 等人深入探讨了这个问题。(1994)，他发现了一些非常根本的原因，为什么这可能很困难。 值得庆幸的是，LSTM 没有这个问题！ ","date":"2023-04-24","objectID":"/lstm_2/:2:0","tags":["LSTM","神经网络","机器学习"],"title":"了解LSTM神经网络","uri":"/lstm_2/"},{"categories":["机器学习"],"content":"长短期记忆网络 长短期记忆网络——通常简称为“LSTM”——是一种特殊的 RNN，能够学习长期依赖关系。它们由Hochreiter \u0026 Schmidhuber (1997)引入，并在后续工作中被许多人提炼和推广。1它们在处理大量问题时表现出色，现在已被广泛使用。 LSTM 明确设计用于避免长期依赖问题。长时间记住信息实际上是他们的默认行为，而不是他们努力学习的东西！ 所有循环神经网络都具有神经网络重复模块链的形式。在标准 RNN 中，这个重复模块将具有非常简单的结构，例如单个 tanh 层。 标准 RNN 中的重复模块包含单层。 LSTM 也有这种链状结构，但重复模块有不同的结构。不是只有一个神经网络层，而是有四个，以一种非常特殊的方式进行交互。 LSTM 中的重复模块包含四个交互层。 不要担心正在发生的事情的细节。稍后我们将逐步介绍 LSTM 图。现在，让我们试着熟悉我们将要使用的符号。 在上图中，每条线都带有一个完整的向量，从一个节点的输出到其他节点的输入。粉色圆圈代表逐点操作，如向量加法，而黄色框是学习的神经网络层。行合并表示串联，而行分叉表示其内容被复制并且副本转到不同的位置。 ","date":"2023-04-24","objectID":"/lstm_2/:3:0","tags":["LSTM","神经网络","机器学习"],"title":"了解LSTM神经网络","uri":"/lstm_2/"},{"categories":["机器学习"],"content":"LSTM 背后的核心思想 LSTM 的关键是细胞状态，即贯穿图表顶部的水平线。 细胞状态有点像传送带。它直接沿着整个链条运行，只有一些次要的线性交互。信息很容易原封不动地沿着它流动。 LSTM 确实有能力删除或添加信息到细胞状态，由称为门的结构仔细调节。 门是一种有选择地让信息通过的方式。它们由一个 sigmoid 神经网络层和一个逐点乘法运算组成。 sigmoid 层输出介于 0 和 1 之间的数字，描述应该让多少成分通过。值为零表示“不让任何东西通过”，而值为 1 表示“让一切都通过！” LSTM 具有三个这样的门，以保护和控制单元状态。 ","date":"2023-04-24","objectID":"/lstm_2/:4:0","tags":["LSTM","神经网络","机器学习"],"title":"了解LSTM神经网络","uri":"/lstm_2/"},{"categories":["机器学习"],"content":"循序渐进的 LSTM 演练 LSTM 的第一步是决定我们要从细胞状态中丢弃哪些信息。该决定由称为“遗忘门层”的 S 形层做出。它看着$h_{t-1}$和$x_t$, 并输出一个介于$0$和$1$对于细胞状态中的每个数字$C_{t-1}$. A$1$代表“完全保留这个”，而一个$0$代表“彻底摆脱这个”。 让我们回到我们的语言模型示例，它试图根据所有先前的单词预测下一个单词。在这样的问题中，细胞状态可能包括当前主体的性别，以便可以使用正确的代词。当我们看到一个新主题时，我们想忘记旧主题的性别。 下一步是决定我们要在细胞状态中存储哪些新信息。这有两个部分。首先，称为“输入门层”的 sigmoid 层决定我们将更新哪些值。接下来，一个 tanh 层创建一个新候选值的向量，$\\tilde{C}_t$，可以将其添加到状态。在下一步中，我们将结合这两者来创建对状态的更新。 在我们的语言模型示例中，我们想要将新主题的性别添加到单元格状态，以替换我们忘记的旧主题。 现在是更新旧细胞状态的时候了，$C_{t-1}$, 进入新的细胞状态$C_t$. 前面的步骤已经决定了要做什么，我们只需要实际去做。 我们将旧状态乘以$f_t$，忘记了我们早些时候决定忘记的事情。然后我们添加$i_t*\\tilde{C}_t$. 这是新的候选值，根据我们决定更新每个状态值的程度进行缩放。 在语言模型的情况下，这是我们实际上要删除有关旧主题性别的信息并添加新信息的地方，正如我们在前面的步骤中所决定的那样。 最后，我们需要决定要输出什么。此输出将基于我们的细胞状态，但将是过滤后的版本。首先，我们运行一个 sigmoid 层，它决定我们要输出细胞状态的哪些部分。然后，我们将细胞状态通过$\\tanh$（将值推到介于$-1$和$1$) 并将其乘以 sigmoid 门的输出，这样我们就只输出我们决定输出的部分。 对于语言模型示例，由于它刚刚看到一个主语，它可能想要输出与动词相关的信息，以防接下来会发生什么。例如，它可能会输出主语是单数还是复数，以便我们知道如果接下来是动词应该变位的形式。 ","date":"2023-04-24","objectID":"/lstm_2/:5:0","tags":["LSTM","神经网络","机器学习"],"title":"了解LSTM神经网络","uri":"/lstm_2/"},{"categories":["机器学习"],"content":"长短期记忆的变体 到目前为止，我所描述的是一个非常普通的 LSTM。但并不是所有的 LSTM 都和上面的一样。事实上，似乎几乎每篇涉及 LSTM 的论文都使用略有不同的版本。差异很小，但值得一提的是其中的一些差异。 由Gers \u0026 Schmidhuber (2000)引入的一种流行的 LSTM 变体正在添加“窥孔连接”。这意味着我们让门层查看单元状态。 上图给所有的门都加了窥视孔，但是很多论文会给一些窥视孔，其他的就不给了。 另一种变体是使用耦合的遗忘门和输入门。我们不是单独决定要忘记什么以及我们应该向什么添加新信息，而是一起做出这些决定。我们只会忘记什么时候要输入一些东西来代替它。当我们忘记旧的东西时，我们只会向状态输入新值。 LSTM 的一个稍微更显着的变化是门控循环单元 (Gated Recurrent Unit, GRU)，由Cho 等人引入。(2014)。它将遗忘门和输入门组合成一个“更新门”。它还合并了细胞状态和隐藏状态，并做了一些其他的改变。生成的模型比标准 LSTM 模型更简单，并且越来越受欢迎。 这些只是一些最著名的 LSTM 变体。还有很多其他的，比如Yao 等人的 Depth Gated RNNs。(2015)。还有一些完全不同的方法来解决长期依赖关系，比如Koutnik 等人的 Clockwork RNNs。(2014)。 这些变体中哪个最好？差异重要吗？格雷夫等人。(2015)对流行的变体进行了很好的比较，发现它们都差不多。Jozefowicz 等人。(2015)测试了超过一万个 RNN 架构，发现其中一些在某些任务上比 LSTM 更有效。 ","date":"2023-04-24","objectID":"/lstm_2/:6:0","tags":["LSTM","神经网络","机器学习"],"title":"了解LSTM神经网络","uri":"/lstm_2/"},{"categories":["机器学习"],"content":"结论 早些时候，我提到了人们使用 RNN 取得的显著成果。基本上所有这些都是使用 LSTM 实现的。对于大多数任务，它们确实工作得更好！ 写成一组方程式，LSTM 看起来相当吓人。希望在本文中逐步介绍它们可以使它们更容易理解。 LSTM 是我们使用 RNN 可以完成的一大步。人们很自然地会想：是否又迈出了一大步？研究人员的共同意见是：“是的！还有下一步，就是注意！这个想法是让 RNN 的每一步都从一些更大的信息集合中挑选信息来查看。例如，如果您使用 RNN 创建描述图像的标题，它可能会选择图像的一部分来查看它输出的每个单词。事实上，徐_等人。_(2015)正是这样做的——如果你想探索注意力，这可能是一个有趣的起点！使用注意力已经取得了许多非常令人兴奋的结果，而且似乎还有更多的结果…… 注意力并不是 RNN 研究中唯一令人兴奋的话题。例如，Kalchbrenner等_人的 Grid LSTM。_(2015)似乎非常有前途。在生成模型中使用 RNN——例如Gregor_等人。_(2015) ,钟_等人。_(2015)或Bayer \u0026 Osendorfer (2015) – 似乎也很有趣。过去几年对于递归神经网络来说是一个激动人心的时期，而即将到来的只会更加精彩！ ","date":"2023-04-24","objectID":"/lstm_2/:7:0","tags":["LSTM","神经网络","机器学习"],"title":"了解LSTM神经网络","uri":"/lstm_2/"},{"categories":["机器学习"],"content":"使用LSTM预测航班延误 ","date":"2023-04-16","objectID":"/lstm/:0:0","tags":["机器学习","LSTM"],"title":"使用LSTM对航班延误进行预测","uri":"/lstm/"},{"categories":["机器学习"],"content":"介绍 航班延误是航空公司和乘客都不愿意面对的问题。在某些情况下，延误可能会导致航空公司的巨额损失，也会影响旅客的日常生活。因此，预测航班延误对于航空公司和旅客来说都非常重要。在本文中，我们将介绍如何使用LSTM来预测航班延误。 ","date":"2023-04-16","objectID":"/lstm/:1:0","tags":["机器学习","LSTM"],"title":"使用LSTM对航班延误进行预测","uri":"/lstm/"},{"categories":["机器学习"],"content":"数据收集和预处理 要预测航班延误，我们需要收集航班数据。我们可以从航空公司、机场网站或第三方数据提供商那里获取数据。在本文中，我们使用开放数据集“航班延误和取消数据”来预测航班延误。在收集数据后，我们需要对数据进行预处理。这包括清洗数据、处理缺失值和异常值等。我们还需要将数据转换为适合LSTM模型的形式。 这个是本文的例子中所用的数据集的来源： ","date":"2023-04-16","objectID":"/lstm/:2:0","tags":["机器学习","LSTM"],"title":"使用LSTM对航班延误进行预测","uri":"/lstm/"},{"categories":["机器学习"],"content":"LSTM模型构建和训练 LSTM是一种适合于序列数据的深度学习模型，常用于时间序列预测。我们可以使用LSTM来预测航班延误。在构建LSTM模型之前，我们需要将数据集分为训练集和测试集。训练集用于训练模型，测试集用于评估模型的性能。在训练LSTM模型时，我们需要确定一些参数，如LSTM层数、神经元个数、迭代次数等。我们还需要选择合适的损失函数和优化器。在训练完模型后，我们可以使用测试集来评估模型的性能。 1.导入包 import pandas as pd from tensorflow.keras import layers,models,optimizers from keras.models import Sequential from tensorflow.keras.layers import Dropout from keras.layers import LSTM,Dense,Flatten from tensorflow.keras.losses import MeanSquaredError from sklearn.preprocessing import LabelEncoder from sklearn.model_selection import train_test_split from keras.callbacks import EarlyStopping import numpy as np import matplotlib.pyplot as plt import tensorflow as tf from os.path import exists !nvidia-smi import os for dirname, _, filenames in os.walk('/kaggle/input'): for filename in filenames: print(os.path.join(dirname, filename)) os.environ['CUDA_VISIBLE_DEVICES'] = \"0\" Thu Apr 13 16:28:46 2023 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 470.161.03 Driver Version: 470.161.03 CUDA Version: 11.4 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Tesla P100-PCIE... Off | 00000000:00:04.0 Off | 0 | | N/A 38C P0 27W / 250W | 0MiB / 16280MiB | 0% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | No running processes found | +-----------------------------------------------------------------------------+ /kaggle/input/us-flight-delay-from-january-2017-july-2022/Airline_Delay_Cause.csv /kaggle/input/airlinedelay/Airline%20Delay.csv /kaggle/input/airline-delay-cause/Airline_Delay_Cause.csv 2.导入数据集 #导入数据集，分为大中小 # df=pd.read_csv('/kaggle/input/us-flight-delay-from-january-2017-july-2022/Airline_Delay_Cause.csv')#mid # df=pd.read_csv('/kaggle/input/airline-delay-cause/Airline_Delay_Cause.csv')#big df=pd.read_csv('/kaggle/input/airlinedelay/Airline%20Delay.csv')#small df.dropna(inplace=True,axis=0) 3.进行简单的数据预处理，这里我使用了中位数进行对每个特征求出对应的值 # 首先通过 df['arr_cancelled']==0 这个条件筛选掉了所有 arr_cancelled 列中值为 1 的行，也就是已经取消的航班。 df=df[df['arr_cancelled']==0] # 然后将 carrier_ct、weather_ct、nas_ct、security_ct 和 late_aircraft_ct 这五列重新赋值，除以 arr_flights 列对应行的值，计算每种延误类型对总到达航班数的占比 arrivingFlights=df['arr_flights'] df['carrier_ct']=df['carrier_ct']/df['arr_flights'] df['weather_ct']=df['weather_ct']/df['arr_flights'] df['nas_ct']=df['nas_ct']/df['arr_flights'] df['security_ct']=df['security_ct']/df['arr_flights'] df['late_aircraft_ct']=df['late_aircraft_ct']/df['arr_flights'] # 接着，将 carrier_delay、weather_delay、security_delay 和 late_aircraft_delay 分别除以 arr_flights 对应行的值，计算每种延误类型对总延误时间的占比。 df['carrier_delay']=df['carrier_delay']/df['arr_flights'] df['weather_delay']=df['weather_delay']/df['arr_flights'] df['security_delay']=df['security_delay']/df['arr_flights'] df['late_aircraft_delay']=df['late_aircraft_delay']/df['arr_flights'] # 将 arr_delay 列除以 arr_flights 对应行的值，计算平均每个到达航班的延误时间。 df['arr_delay']=df['arr_delay']/df['arr_flights'] # 计算 arr_delay 列的标准差和均值，然后求出阈值（threshhold），这里将阈值设为平均值加两倍标准差。 std=df['arr_delay'].std() mean=df['arr_delay'].mean() threshhold=mean+2*std filter=((df['arr_delay']\u003cthreshhold)) # 最后根据阈值和 arr_delay 列的值进行筛选，将 arr_delay 列的值小于阈值的行保留，其余行删除，即剔除过度偏离平均水平的异常值，返回一个新的数据帧 df。 df=df[filter] # 画图，延误的分钟，横坐标为时间序 df['carrier_delay'].plot(legend='Carrier') df['weather_delay'].plot(legend='Weather') df['security_delay'].plot(legend='Security') df['late_aircraft_delay'].plot(legend='Late') plt.title('delay in minutes') plt.legend() plt.show() # 从这里我们可以看到，大多数的延误时间在10-15分","date":"2023-04-16","objectID":"/lstm/:3:0","tags":["机器学习","LSTM"],"title":"使用LSTM对航班延误进行预测","uri":"/lstm/"},{"categories":["机器学习"],"content":"模型预测和评估 在模型训练完成后，我们可以使用该模型来预测航班延误。我们可以将实时数据输入到模型中，模型将输出延误的概率。我们还可以使用各种指标来评估模型的性能，如平均绝对误差、均方误差等。如果模型的性能不够好，我们可以尝试调整模型参数、增加训练数据等方法来提高模型性能。 ","date":"2023-04-16","objectID":"/lstm/:4:0","tags":["机器学习","LSTM"],"title":"使用LSTM对航班延误进行预测","uri":"/lstm/"},{"categories":["机器学习"],"content":"总结 本文介绍了如何使用LSTM来预测航班延误。我们需要收集和预处理数据，构建和训练LSTM模型，使用模型预测和评估模型性能。预测航班延误对于航空公司和旅客都非常重要，希望这篇文章能够帮助你了解如何使用LSTM来预测航班延误。 ","date":"2023-04-16","objectID":"/lstm/:5:0","tags":["机器学习","LSTM"],"title":"使用LSTM对航班延误进行预测","uri":"/lstm/"},{"categories":["区块链","零知识"],"content":"零知识机器学习（ZKML）简介","date":"2023-04-06","objectID":"/zkml/","tags":["区块链","零知识","机器学习","zk"],"title":"零知识机器学习（ZKML）简介","uri":"/zkml/"},{"categories":["区块链","零知识"],"content":"零知识机器学习（ZKML）简介 Zero-Knowledge 机器学习（ZKML）是最近正在密码学界引起轰动的一个研究和开发领域。但它是什么，有什么用处呢？首先，让我们把这个术语分解成它的两个组成部分，并解释一下它们是什么。 ","date":"2023-04-06","objectID":"/zkml/:0:0","tags":["区块链","零知识","机器学习","zk"],"title":"零知识机器学习（ZKML）简介","uri":"/zkml/"},{"categories":["区块链","零知识"],"content":"什么是 ZK？ 零知识证明是一种密码协议，其中一方（证明者）可以向另一方（验证者）证明一个给定的陈述是真实的，而不泄露除该陈述为真以外的任何附加信息。这是一个正在各个方面取得巨大进展的研究领域，涵盖了从研究到协议实施和应用的所有方面。 ZK 提供的两个主要“原语”（或者说构建块）是能够为一组给定的计算创建具有计算完整性证明的能力，其中证明比执行计算本身要容易地多。（我们称这种属性为“简洁性”）。ZK 证明也提供了隐藏计算中某些部分同时保持计算正确性的选项。（我们称这种属性为“零知识性”）。 生成零知识证明需要非常大的计算量，大约比原始计算贵 100 倍。这意味着，在某些情况下由于最佳硬件上生成它们所需的时间使其不切实际，因此不能计算零知识证明。 然而，在近年来密码学、硬件和分布式系统领域的进步已经使零知识证明成为了越来越强大的计算可行的选择。这些进展已经为可以使用计算密集型证明的协议的创建提供了可能，从而扩大了新应用程序的设计空间。 ZK 使用案例 零知识密码学是 Web3 空间中最流行的技术之一，因为它允许开发人员构建可扩展和/或私有的应用程序。以下是一些实践中如何使用它的示例（尽管请注意，这些项目中许多都还在进行中）： 1.通过 ZK rollups 扩展以太坊 Starknet Scroll Polygon Zero，Polygon Miden，Polygon zkEVM zkSync 2.构建保护隐私的应用程序 Semaphore MACI Penumbra Aztec Network 3.身份原语和数据来源 WorldID Sismo Clique Axiom 4.第一层协议 Zcash Mina 随着 ZK 技术的成熟，我们相信将会出现新的应用程序的爆发，因为构建这些应用程序所使用的工具将需要更少的领域专业知识，对于开发人员来说将会更加容易使用。 ","date":"2023-04-06","objectID":"/zkml/:1:0","tags":["区块链","零知识","机器学习","zk"],"title":"零知识机器学习（ZKML）简介","uri":"/zkml/"},{"categories":["区块链","零知识"],"content":"ZKML 的动机和当前的努力 我们生活在一个世界上，AI/ML 生成的内容越来越难以与人类生成的内容区分开来。零知识密码学将使我们能够做出这样的声明：“给定一段内容 C，它是由模型 M 应用于一些输入 X 生成的。”我们将能够验证某个输出是否是由大型语言模型（如 chatGPT）或文本到图像模型（如 DALL-E 2）等任何其他我们为其创建了零知识电路表示的模型所生成的。这些证明的零知识属性将使我们能够根据需要也隐藏输入或模型的某些部分。一个很好的例子是在一些敏感数据上应用机器学习模型，在不透露输入到第三方的情况下，用户可以知道他们的数据在模型推理后的结果（例如，在医疗行业）。 注：当我们谈论 ZKML 时，我们是指创建 ML 模型推理步骤的零知识证明，而不是关于 ML 模型训练（它本身已经非常计算密集）。目前，现有技术水平的零知识系统加上高性能硬件仍然相差几个数量级，无法证明当前可用的大型语言模型（LLMs）等庞大的模型，但是在创建较小模型的证明方面已经取得了一些进展。 我们对零知识密码学在为 ML 模型创建证明的上下文中的现有技术水平进行了一些研究，并创建了一个聚合相关研究、文章、应用程序和代码库的文章集。ZKML 的资源可以在 GitHub 上的 ZKML 社区的 awesome-zkml 存储库中找到。 Modulus Labs 团队最近发布了一篇名为“智能的成本”的论文，其中对现有的 ZK 证明系统进行了基准测试，并列举了不同大小的多个模型。目前，使用像 plonky2 这样的证明系统，在强大的 AWS 机器上运行 50 秒左右，可以为约 1800 万个参数的模型创建证明。以下是该论文中的一张图表： 另一个旨在改进 ZKML 系统技术水平的倡议是 Zkonduit 的 ezkl 库，它允许您创建对使用 ONNX 导出的 ML 模型的 ZK 证明。这使得任何 ML 工程师都能够为他们的模型的推理步骤创建 ZK 证明，并向任何正确实现的验证器证明输出。 有几个团队正在改进 ZK 技术，为 ZK 证明内部发生的操作创建优化硬件，并针对特定用例构建这些协议的优化实现。随着技术的成熟，更大的模型将在较不强大的机器上短时间内进行 ZK 证明。我们希望这些进展将使新的 ZKML 应用程序和用例得以出现。 ","date":"2023-04-06","objectID":"/zkml/:2:0","tags":["区块链","零知识","机器学习","zk"],"title":"零知识机器学习（ZKML）简介","uri":"/zkml/"},{"categories":["区块链","零知识"],"content":"潜在的使用案例 为了确定 ZKML 是否适用于特定的应用，我们可以考虑 ZK 密码学的特性将如何解决与机器学习相关的问题。这可以用一个 Venn 图来说明： 定义： 1.Heuristic optimization启发式优化—— 一种问题解决方法，它使用经验法则或“启发式”来找到艰难的问题的好解决方案，而不是使用传统的优化方法。启发式优化方法旨在在相对的重要性和优化难度下，在合理的时间内找到好的或“足够好”的解决方案，而不是尝试找到最优解决方案。 2.FHE ML全同态加密—— 完全同态加密ML允许开发人员以保护隐私的方式训练和评估模型；然而，与ZK证明不同，没有办法通过密码学方式证明所执行的计算的正确性。 像 Zama.ai这样的团队正在从事这个领域的工作。 3.ZK vs Validity —— 在行业中，这些术语通常被互换使用，因为有效性证明是ZK证明，不会隐藏计算或其结果的某些部分。在ZKML的上下文中，大多数当前的应用程序都利用了ZK证明的有效性证明方面。 4.Validity ML —— ZK证明ML模型，在其中没有计算或结果被保密。它们证明计算的正确性。 以下是一些潜在的 ZKML 用例示例： 1.计算完整性（有效性 ML） Modulus Labs模量实验室 基于链上可验证的 ML 交易机器人 - RockyBot 自我改进视觉区块链（示例）： 增强 Lyra 金融期权协议 AMM 的智能特性Lyra 金融期权协议 AMM 为 Astraly 创建透明的基于 AI 的声誉系统（ZK oracle） 使用 ML for Aztec Protocol（具有隐私功能的 zk-rollup）致力于合同级合规工具所需的技术突破。 2.机器学习即服务(MLaaS) 透明； 3.ZK 异常/欺诈检测： 这种应用场景使得可创建针对允许为可利用性/欺诈的 ZK 证明成为可能。异常检测模型可以在智能合约数据上进行训练，并由 DAOs 同意作为有趣的度量标准，以便能够自动化安全程序，如更主动、预防性地暂停合约。已有初创企业正在研究在智能合约环境中使用 ML 模型进行安全目的的方法，因此 ZK 异常检测证明似乎是自然的下一步。 4.ML 推理的通用有效性证明：能够轻松证明和验证输出是给定模型和输入对的乘积。 5.隐私 (ZKML)。 6.去中心化的 Kaggle：证明模型在某些测试数据上的准确率大于 x%，而不会显示权重。 7.隐私保护推理：将对私人患者数据的医疗诊断输入模型，并将敏感的推理（例如，癌症测试结果）发送给患者。（来源：vCNN 论文，第 2/16 页） 8.Worldcoin： IrisCode 的可升级性：World ID 用户将能够在他们的移动设备的加密存储中自我保管其生物特征，下载用于生成 IrisCode 的 ML 模型并在本地创建零知识证明，以证明其 IrisCode 已成功创建。这个 IrisCode 可以被无需许可地插入注册的 Worldcoin 用户之一，因为接收的智能合约可以验证零知识证明，从而验证 IrisCode 的创建。这意味着，如果 Worldcoin 将来升级机器学习模型以一种破坏与其之前版本兼容性的方式创建 IrisCode，用户就不必再次去 Orb，而可以在设备上本地创建这个零知识证明。 Orb 安全性：目前，Orb 在其受信任的环境中执行几个欺诈和篡改检测机制。然而，我们可以创建一个零知识证明，表明这些机制在拍摄图像和生成 IrisCode 时是活动的，以便为 Worldcoin 协议提供更好的活体保证，因为我们可以完全确定这些机制在整个 IrisCode 生成过程中都将运行。 总之，ZKML 技术有着广泛的应用前景，并且正在快速发展。随着越来越多的团队和个人加入到这个领域，我们相信 ZKML 的应用场景将会更加多样化和广泛化。 ","date":"2023-04-06","objectID":"/zkml/:3:0","tags":["区块链","零知识","机器学习","zk"],"title":"零知识机器学习（ZKML）简介","uri":"/zkml/"},{"categories":["区块链"],"content":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","date":"2023-03-22","objectID":"/fabric_bug/","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"1. 不要尝试获取节点本地的时间作为key或value的值 即使每个节点的本地的时间系统是经过校对一致的，但同一个交易在每个节点上执行的时间点不一定是相同的。如果使用time.now().unix()来取节点本地的时间作为key或value的值，会导致每个节点执行同一个交易的结果不一致，从而造成交易失败。正确的做法是使用函数GetTxTimestamp()来获取交易的时间。每个节点通过函数GetTxTimestamp()来获取到的交易时间是相同的 例子： t, err := stub.GetTxTimestamp() t.Seconds // 交易的时间，unix时间戳，精确到秒 t.Nanos// 交易的时间，unix时间戳，精确到纳秒 time.Unix(t.Seconds, int64(t.Nanos)).UnixNano() / 1e6 // 交易的时间，unix时间戳，精确到毫秒 但需要注意的是，每个节点通过函数GetTxTimestamp()来获取到的交易时间是相同的，但它取到的时间是客户端创建交易时的本地时间。如果客户端的本地时间没有校准的话，GetTxTimestamp()获取到的交易时间也是不准确的。 ","date":"2023-03-22","objectID":"/fabric_bug/:1:0","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"2. 在同一个区块里多笔交易对同一键进行更新 对同一键进行更新的一个或多笔交易打包到同一块中，只有第1笔交易会成功，后面的交易会失败。相关的原因是：在一个区块里的多笔交易，只有在区块被提交后才会真正生效。而每一个键值都有版本号，假设一个键“key_1”在本个区块提交前的版本号为9，然后在本个区块里有2笔交易分别更新键\"key_1\"的值为\"123\"和\"456\"。那么当第1笔交易更新键“key_1”的值时，键\"key_1\"的版本号在本个区块里将更新为10，但在本区块未提交前，真正生效的版本号还是9。而当执行第2笔交易时，该交易读取到键\"key_1\"的版本号还是9，这样第2笔交易还是把键\"key_1\"的版本号更新为10，这样系统会判断为“双花”行为，从而引起冲突，导致只有第1笔交易会执行成功，第2笔交易执行失败。具体可以参考这篇文章 https://learnblockchain.cn/article/620 简单地说，在同一个区块里多笔交易对同一键进行PutState()更新时，只有一笔交易是成功的，其它的交易会出现 MVCC_READ_CONFLICT报错。 因此，试图在fabric合约里创建全局的计数器是一件不可靠的事情。 ","date":"2023-03-22","objectID":"/fabric_bug/:2:0","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"3. 在同一个区块里多笔交易先后对同一个键进行更新和读取 假设在一个区块里有2笔交易，第1笔交易对键\"key_1\"值更新为\"123\"，第2笔交易尝试读取键\"key_1\"的值，结果第2笔交易读键\"key_1\"的值结果为空。原因上面已经提及到，一个区块里的多笔交易，只有在区块被提交后才会真正生效。 ","date":"2023-03-22","objectID":"/fabric_bug/:3:0","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"4. 在一个方法内对同一个键先写后读 在一个方法内对同一个键先进行写键值（putState()），然后再进行读键值（getState()），会发现前面的putState操作没有生效，原因也是同前面一样的道理 ","date":"2023-03-22","objectID":"/fabric_bug/:4:0","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"5. 尝试通过合约使用加密算法对信息进行加密 有些加密算法对同样内容的信息进行加密，有可能每次加密的结果是不一样的。例如：RSA公钥对同一数据加密，每次的结果都不一样。这样会导致不同的节点执行加密的结果不一样，从而导致提交的内容不一致，造成交易失败 ","date":"2023-03-22","objectID":"/fabric_bug/:5:0","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"6. 没有了解query和invoke的合约函数调用方式 超级账本调用合约函数的方式有2种：query和invoke 通过query方式调用合约函数，只能查询链上数据，不能向链上写数据，并且不产生交易 通过invoke方式调用合约函数，可以向链上写数据，并产生交易 如果一个合约函数里调用了PutState()操作，但是通过query方式来调用该合约函数，虽然不会报错，但PutState()操作实际没有生效，世界状态不会被改变 如果一个合约函数里没有调用PutState()操作，但是通过invoke方式来调用该合约函数，虽然不会报错，但却会产生交易 ","date":"2023-03-22","objectID":"/fabric_bug/:6:0","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"7. 使用CouchDB，在使用select语句时没有对select的字段建立索引 超级账本可以使用Leveldb或CouchDB。如果要支持富查询，一般会选择使用CouchDB。CouchDB可以支持类似于SQL的select语句来实现富查询。但是CouchDB的效率并不高，在不建立索引的情况下，可能对2-3万条的数据使用select语句就会导致查询非常耗时，从而导致合约函数的执行超时而失败。而对于传统的关系型数据库，2-3万条的数据量，在不建立索引的情况下，对查询的影响不是很明显。 例如下面的select语句： “{“selector”:{“StudentAge”:{\"$lte”: 10}, “sort”:[{“RegisterTime”: “asc”}]}}\" 最好就需要对字段StudentAge和RegisterTime建立索引。 想知道CouchDB在执行一条查询语句究竟有没有使用索引，用了哪些索引，可以通过向CouchDB发送post请求的方法，通过返回的response来查看使用了哪些索引。具体可参考下面的链接 https://docs.couchdb.org/en/latest/api/database/find.html#db-explain 1.3.8. /db/_explain 这一节的内容 具体的操作可以通过postman来实现， post的地址如http://127.0.0.1:5984/member_goods/_explain 发送的body就是查询select语句的内容， 注意header里需要配置一个KeyValue Content-Type:application/json ","date":"2023-03-22","objectID":"/fabric_bug/:7:0","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"8. 使用CouchDB，在使用select语句时尽量避免使用sort进行排序 sort排序会严重消耗查询时间，容易造成查询超时，应尽量避免使用。使用sort语句，必须对sort语句中涉及的字段创建索引，否则会报错。 ","date":"2023-03-22","objectID":"/fabric_bug/:8:0","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"9.搭建Fabric区块链浏览器的坑 搭建Fabric区块链浏览器的时，如果之前曾经在同一台机器上使用不同的用户证书搭建过Fabric区块链浏览器，那么在同一台机器上使用新的用户证书搭建Fabric区块链浏览器时，一定要运行下面的命令清除之前的容器服务里的volume残留值： docker-compose down -v 详细可以参考这篇文章 https://blog.csdn.net/lyz19961221/article/details/118576529 ","date":"2023-03-22","objectID":"/fabric_bug/:9:0","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"10.避免Fabric的智能合约函数陷入死循环 合约函数陷入死循环，不但会导致本次合约函数执行超时，而且后面会导致无法执行其它合约函数的问题，后果非常严重，详细可以参考这篇文章 https://zhuanlan.zhihu.com/p/572782459 ","date":"2023-03-22","objectID":"/fabric_bug/:10:0","tags":["区块链","Hyperledger Fabric","智能合约"],"title":"在超级账本Hyperledger Fabric中开发智能合约遇到的问题","uri":"/fabric_bug/"},{"categories":["区块链"],"content":"solidity 内存(memory) 可变数组(动态数组) 的 增删改查","date":"2023-03-17","objectID":"/solidity_curd/","tags":["solidity","区块链"],"title":"solidity动态数组的增删改查","uri":"/solidity_curd/"},{"categories":["区块链"],"content":"数组类型 Solidity支持两种数组: 静态数组和动态数组。 又分storage与memory型数组 uint[] memory list; //变长memory数组，使用前必须确定长度 list =new uint[](a); //然后再使用，一般用在函数内 memory型数组不能使用pop,push也不能修改length ","date":"2023-03-17","objectID":"/solidity_curd/:1:0","tags":["solidity","区块链"],"title":"solidity动态数组的增删改查","uri":"/solidity_curd/"},{"categories":["区块链"],"content":"静态数组 // 固定长度为2的静态数组定义 uint[2] fixedArray; //定长数组实例化 fixedArray = [4, 6]; 静态数组不可新增元素，但可修改现有元素的值。 ","date":"2023-03-17","objectID":"/solidity_curd/:1:1","tags":["solidity","区块链"],"title":"solidity动态数组的增删改查","uri":"/solidity_curd/"},{"categories":["区块链"],"content":"动态数组 动态数组，长度不固定，可以动态添加元素。 //声明 uint[] dynamicArray; //初始化，这里实例化一个长度为2的数组，值为0。 dynamicArray = new uint[](2); // SPDX-License-Identifier: MIT pragma solidity ^0.8.9; library Array { function push(uint256[] memory _nums, uint256 _num) internal pure { assembly { // 在可变数组的 末尾追加 一个value (_num) mstore(add(_nums, mul(add(mload(_nums), 1), 0x20)), _num) // 可变数组的length 加 1 mstore(_nums, add(mload(_nums), 1)) // 0x40 是空闲内存指针的预定义位置 (value 为 空闲指针开始位) mstore(0x40, add(mload(0x40), 0x20)) } } function pop(uint256[] memory _nums) internal pure returns (uint256 num_) { assembly { // 取出可变数组的最后一个value num_ := mload(add(_nums, mul(mload(_nums), 0x20))) // length - 1 mstore(_nums, sub(mload(_nums), 1)) } } function del(uint256[] memory _nums, uint256 _index) internal pure { assembly { // 下标位置需 小于 数组.length if lt(_index, mload(_nums)) { // 将最后一个value 移到 _index 下标处 mstore( add(_nums, mul(add(_index, 1), 0x20)), mload(add(_nums, mul(mload(_nums), 0x20))) ) // length - 1 mstore(_nums, sub(mload(_nums), 1)) } } } function update( uint256[] memory _nums, uint256 _index, uint256 _num ) internal pure { _nums[_index] = _num; } function get(uint256[] memory _nums, uint256 _index) internal pure returns (uint256) { return _nums[_index]; } } contract testArr { using Array for uint256[]; function push(uint256[] memory _nums, uint256 num) external pure returns (uint256[] memory) { _nums.push(num); return _nums; } function pop(uint256[] memory _nums) external pure returns (uint256[] memory, uint256) { uint256 num_ = _nums.pop(); return (_nums, num_); } function del(uint256[] memory _nums, uint256 _index) external pure returns (uint256[] memory) { _nums.del(_index); return _nums; } function update( uint256[] memory _nums, uint256 _index, uint256 _num ) external pure returns (uint256[] memory) { _nums.update(_index, _num); return _nums; } function get(uint256[] memory _nums, uint256 _index) external pure returns (uint256) { return _nums.get(_index); } } ","date":"2023-03-17","objectID":"/solidity_curd/:1:2","tags":["solidity","区块链"],"title":"solidity动态数组的增删改查","uri":"/solidity_curd/"},{"categories":["区块链"],"content":"OrderBook的实现思路","date":"2023-03-15","objectID":"/orderbook/","tags":["区块链","OrderBook"],"title":"OrderBook的实现思路","uri":"/orderbook/"},{"categories":["区块链"],"content":"什么是OrderBook OrderBook是一个包含了所有交易者信息的订单集合，他们想买或者想卖。想买的order叫做bid，想卖的order叫做ask，这些bid和ask的order一旦满足了各自的条件，就会尽可能快的完成配对，促成一笔交易。这里有两个种类的order需要介绍一下，它们也是最为基本的交易订单。第一种是市价 market order，买和卖都是依据当前在orderbook能寻找到的最优价格执行。第二种是限价 limit order，买和卖都是按照已经确定量和价格进行。OrderBook是传统金融中一个很重要的交易方式，通过OrderBook中显示的信息，可以判断当前市场的供需关系以及价格关系，基于以上的判断可以对市场中的下一步发生的变化进行一个判断。在去中心化金融(Defi)，刚开始发展时也借鉴到了OrderBook的模式，由于传统的OrderBook由中心化机构进行给出，导致了信息中心化不透明。所以在Defi中想实现一个OrderBook完全只有买方和卖方进行参与，而机构只收取相依的手续费即可。 看起来这样的想法是一种很不错的想法，提供了一个更加公平和自由度更高的一个市场让人们去操作。但是在实际中进行时会发现问题： 对于OrderBook需求来说整个区块链网络中交易成交的速率和数量都无法满足，即使以太坊的速率相较于比特币网络有了很大的提高。 在交易中有gas的存在，如果没有一种很好的方法去定位到合适的订单的话，随着订单数量的变多，找到相应订单所需的gas会消耗很大。并且每笔交易都有一个gas上限，当gas达到相应上限的时候就会导致交易失败。 ","date":"2023-03-15","objectID":"/orderbook/:1:0","tags":["区块链","OrderBook"],"title":"OrderBook的实现思路","uri":"/orderbook/"},{"categories":["区块链"],"content":"实现OrderBook思路 ","date":"2023-03-15","objectID":"/orderbook/:2:0","tags":["区块链","OrderBook"],"title":"OrderBook的实现思路","uri":"/orderbook/"},{"categories":["区块链"],"content":"一般的思路 抛开以太坊特殊的条件，我们在实现OrderBook的时候，采用的最常用的方法就是蛮力法。思路： 创建买单和买单两个数组 当有买单创建的时候，对买单数组进行遍历，找到对应价格对应数量的订单，完成一笔交易。如果没找到，将买单加入买单数组。同理创建卖单时也进行相应的操作。 这个方法能确保找到所需要的的交易，但是整个过程的时间复杂度为O(n),然后可以进行并发和互斥锁结合，可以在短时间内处理大量的买单和买单满足需求。但是随着订单量的增多，所需要的时间也会增多，这在链上和链下的环境中都是不能接受的。 但是，如果不采用蛮力法的话，将买单和卖单分别用排序二叉树的方式进行数据保存，那样的话时间复杂度就会变为O(logn)，这样可以优化查找，只是在插入是有点麻烦。 ","date":"2023-03-15","objectID":"/orderbook/:3:0","tags":["区块链","OrderBook"],"title":"OrderBook的实现思路","uri":"/orderbook/"},{"categories":["区块链"],"content":"换种思路 在智能合约中我们要尽量避免时使用循环的方式，这是很费gas的。而为了确保能够得到想要的价格。我们可以这样设计： 创建两个买单和卖单的两个映射 mapping(uint =\u003e mapping(uint =\u003e address[])) Bid; mapping(uint =\u003e mapping(uint =\u003e address[])) Ask; 前一个uint是价格，第二个uint是数量，最后面的是卖方或买方的地址； 每次有买单和卖单进来的时候，在mapping中进行搜索，完成交易。搜索不到的话加入对应的mapping中即可。 看上去这样的两个映射可以解决买卖双方的订单的查找的时间复杂度问题（将时间复杂度降为O(1)）。但是这样却忽略了一个问题，这样做我们无法看到整个市场的变化和趋势。我们这样设计代码的话只是实现了OrderBook的一部分功能。如果想要实现OrderBook，还有很多要进行修改的地方。 ","date":"2023-03-15","objectID":"/orderbook/:4:0","tags":["区块链","OrderBook"],"title":"OrderBook的实现思路","uri":"/orderbook/"},{"categories":["区块链"],"content":"第三种思路 在链上尽量不要使用大循环，但是我们可以将大循环变为小的循环，这样来说是可以的。同时我们也要反映整个OrderBook的变化，我们就可以设计一个压缩前缀树： 树中的每个节点为数字0~9，这样从头结点到叶子节点前的节点就可以连成一串数字，这个数字表示金额，每个叶子节点储存的是订单数组，每个订单保存了在此金额下的数量和地址。 同样树也要分两颗树，买家树和卖家树。 每次有新金额出现时，要对树进行修改，对树进行扩展，保证从头到尾连成的数字为金额。 同时当金额对应的叶子节点中数组长度为0时，要对树进行删除，这样做的目的是保证在对树遍历时减少时间消耗。 在新买单创建时，先在卖家树中找到对应金额的数组，在对数组进行遍历找到对应金额(此时就将大循环优化为一个小循环)，找到对应订单后就成交交易。没找到的话就将其加入买家树。(同理，卖单也是这样处理) 这样的话就可以兼顾市场变化和挂单的需求。 ","date":"2023-03-15","objectID":"/orderbook/:5:0","tags":["区块链","OrderBook"],"title":"OrderBook的实现思路","uri":"/orderbook/"},{"categories":["区块链"],"content":"问题 以上的思路都可以实现OrderBook，但是还有许多问题需要进行考虑： 如果对应的数量找不到，但是存在两个或两个以上的订单之和满足要求的时候，要怎么进行处理？在时间复杂度较小的前提下如何完成这个拆分寻找的过程？ 整个树的结构要如何设计？才能使得在增删改查较为方便？ ","date":"2023-03-15","objectID":"/orderbook/:6:0","tags":["区块链","OrderBook"],"title":"OrderBook的实现思路","uri":"/orderbook/"},{"categories":["区块链"],"content":"结尾 虽然现在主流的DEX没有使用OrderBook，而是使用LP这样的方式，但是LP也会存在着很多的问题需要解决。正是因为OrderBook的一些功能无法满足Defi的需求，所以才会有LP的出现。技术的适用性是需要结合需求的。或许在以后可能会产生适应区块链的OrderBook。 ","date":"2023-03-15","objectID":"/orderbook/:7:0","tags":["区块链","OrderBook"],"title":"OrderBook的实现思路","uri":"/orderbook/"},{"categories":["java"],"content":"使用springboot整合OpenAI的chatgpt api和whisper api","date":"2023-03-13","objectID":"/springboot-openai/","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"Springboot+Chatgpt+Whisper api 本文通过springboot将两个OpenAI API的其中两个，ChatGPT和Whisper API集成在一起，方便后续的开发。 ","date":"2023-03-13","objectID":"/springboot-openai/:0:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"OpenAI API OpenAI是人工智能和机器学习工具及API的领先提供商之一。它训练了尖端的语言模型，擅长理解和生成文本。OpenAI API提供对这些模型的访问，并可用于解决几乎涉及处理语言的任何任务。它可以执行包括但不限于以下任务： Content generation 内容生成 Summarization 总结 Classification, categorization, and sentiment analysis 分类、归类和情感分析 Data extraction 数据提取 Translation 翻译 Transcription 转录 Image generation 图像生成 我们可以通过任何语言发出HTTP请求与API进行交互。在本篇文章中，我们将使用Java构建一个Spring Boot微服务来集成Chatgpt API和Whisper API语音转文字功能。 ","date":"2023-03-13","objectID":"/springboot-openai/:1:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"集成chatgpt-whisper-spring-boot 首先我们打开IDEA新建一个springboot项目 然后往其中的pom.xml文件添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003cversion\u003e4.0.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-configuration-processor\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e ","date":"2023-03-13","objectID":"/springboot-openai/:2:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"Spring Cloud OpenFeign 对于第三方REST API集成，有许多可以用的工具，这里我们选择Spring Cloud OpenFeign，因为这个对于Spring Boot 3支持方面比较好。 接下来我们打开 application.yml，往其中添加下面的内容： openai-service: api-key: xxxxxxxxxx gpt-model: gpt-3.5-turbo audio-model: whisper-1 http-client: read-timeout: 60000 connect-timeout: 60000 urls: base-url: https://chat.579878700.xyz/v1 chat-url: /chat/completions create-transcription-url: /audio/transcriptions 其中 api-key请填写自己的api key，如果您还没有API密钥，请到https://platform.openai.com/account/api-keys 以生成API密钥。实际开发中这种配置肯定要放在配置中心里面，但是我们今天先简单的写个demo。 gpt-model ： gpt-3.5-turbo ，功能最强大的GPT-3.5模型，针对聊天进行了优化，成本仅为 text-davinci-003 的1/10，它可以执行任何语言任务，质量更好，输出更长，指令一致。 audio-model ： whisper-1 ，通用语音识别模型。它是在一个大型的多样化音频数据集上进行训练的，也是一个多任务模型，可以执行多语言语音识别以及语音翻译和来自世界各地大约100种不同语言的音频文件的语言识别。 read-time和 connect-time可以根据实际需求更改，这里我使用中文来回答，因此我设置的大一些，避免回答返回时间太长导致超时问题。 base-url这里我填写的是我使用CF进行反代的地址，因为一些原因，openai api在中国不能直接访问，所以使用这个方法。如果不需要，请改成 https://api.openai.com/v1 urls ：根据OpenAI API文档，所有API URL均以 [https://api.openai.com/v1](https://api.openai.com/v1) 开头。我们将其定义为 base-url 。对于聊天功能， chat-url 被定义为 /chat/completions 。对于音频转录， create-transcription-url 被定义为 /audio/transcriptions 。 我们使用 /chat/completions 继续使用 gpt-3.5-turbo 模型。 ","date":"2023-03-13","objectID":"/springboot-openai/:3:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"Feign Client 现在配置已经完成，让我们继续编写声明式Feign客户端，我们需要两个方法： chat 和 createTranscription ，调用它们各自的OpenAI API端点URL。你可以随意命名这些方法，为了简单起见，让我们继续使用 chat 和 createTranscription 。 @FeignClient( name = \"openai-service\", url = \"${openai-service.urls.base-url}\", configuration = OpenAIClientConfig.class ) public interface OpenAIClient { @PostMapping(value = \"${openai-service.urls.chat-url}\", headers = {\"Content-Type=application/json\"}) ChatGPTResponse chat(@RequestBody ChatGPTRequest chatGPTRequest); @PostMapping(value = \"${openai-service.urls.create-transcription-url}\", headers = {\"Content-Type=multipart/form-data\"}) WhisperTranscriptionResponse createTranscription(@ModelAttribute WhisperTranscriptionRequest whisperTranscriptionRequest); } ","date":"2023-03-13","objectID":"/springboot-openai/:4:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"Models 通过严格遵循API文档，我们先定义请求/响应类。请参见下面使用 gpt-3.5-turbo 模型的示例请求和响应类。注意，使用 text-davinci-003 完成的请求/响应略有不同，有关详细信息，请参阅API文档。 @Data @Builder @AllArgsConstructor @NoArgsConstructor public class ChatGPTRequest implements Serializable { private String model; private List\u003cMessage\u003e messages; } @Data public class ChatGPTResponse implements Serializable { private String id; private String object; private String model; private LocalDate created; private List\u003cChoice\u003e choices; private Usage usage; } 使用 Whisper 模型的音频转录请求/响应示例： @Data @Builder @AllArgsConstructor @NoArgsConstructor public class TranscriptionRequest implements Serializable { private MultipartFile file; } @Data public class WhisperTranscriptionResponse implements Serializable { private String text; } ","date":"2023-03-13","objectID":"/springboot-openai/:5:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"Service 下面是服务层类 OpenAIClientService ，构造模型并调用Feignclient以触发对OpenAI API的调用。 @Service @RequiredArgsConstructor public class OpenAIClientService { private final OpenAIClient openAIClient; private final OpenAIClientConfig openAIClientConfig; private final static String ROLE_USER = \"user\"; public ChatGPTResponse chat(ChatRequest chatRequest){ Message message = Message.builder() .role(ROLE_USER) .content(chatRequest.getQuestion()) .build(); ChatGPTRequest chatGPTRequest = ChatGPTRequest.builder() .model(openAIClientConfig.getModel()) .messages(Collections.singletonList(message)) .build(); return openAIClient.chat(chatGPTRequest); } public WhisperTranscriptionResponse createTranscription(TranscriptionRequest transcriptionRequest){ WhisperTranscriptionRequest whisperTranscriptionRequest = WhisperTranscriptionRequest.builder() .model(openAIClientConfig.getAudioModel()) .file(transcriptionRequest.getFile()) .build(); return openAIClient.createTranscription(whisperTranscriptionRequest); } } 请注意，除了必需参数之外，我们还可以在请求正文中传递多个可选参数来指示 OpenAI API。例如，对于/chat/completions，我们可以传入temperature参数，它告诉 OpenAI API 使用什么采样温度，介于 0 和 2 之间。较高的值将使输出更具随机性和风险性，而较低的值会使它更集中和确定性。temperature如果我们不指定，默认值为 1。请参阅OpenAI API 文档，了解我们可以在请求正文中传递的所有可能的参数。 ","date":"2023-03-13","objectID":"/springboot-openai/:6:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"REST Controller REST 最后，让我们看看REST Controller层的 OpenAIClientController ，里面的两个客户端： chat （ /api/v1/chat ）：POST调用，使用JSON格式的消息，接受一个问题，并输出响应内容。 createTranscription （ /api/v1/transcription ）：POST调用，使用multipart/form-data，因为我们要上传音频文件，如 m4a和 mp3等音频文件 ，API将把音频文件转录为文本。 @RestController @RequiredArgsConstructor @RequestMapping(value = \"/api/v1\") public class OpenAIClientController { private final OpenAIClientService openAIClientService; @PostMapping(value = \"/chat\", consumes = MediaType.APPLICATION_JSON_VALUE) public ChatGPTResponse chat(@RequestBody ChatRequest chatRequest){ return openAIClientService.chat(chatRequest); } @PostMapping(value = \"/transcription\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE) public WhisperTranscriptionResponse createTranscription(@ModelAttribute TranscriptionRequest transcriptionRequest){ return openAIClientService.createTranscription(transcriptionRequest); } } ","date":"2023-03-13","objectID":"/springboot-openai/:7:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"Authentication 认证 OpenAI API调用需要传入一个带有API密钥的请求头“ Authorization “。让我们声明一个 RequestInterceptor bean来处理它，参见 OpenAIClientConfig 类的示例代码片段： @Bean public RequestInterceptor apiKeyInterceptor() { return request -\u003e request.header(\"Authorization\", \"Bearer \" + apiKey); } ","date":"2023-03-13","objectID":"/springboot-openai/:8:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"最后运行项目 用Postman测试一下 下面是 /chat 客户端的示例请求/响应截图： 下面是 /transcription 的请求/响应： 感觉对中文的识别准确度还是可以的。 使用Whisper模型的音频转录或翻译，文件上传目前限制为25 MB，并支持以下输入文件类型：mp3, mp4, mpeg, mpga, m4a, wav, webm Whisper型号的定价目前设定为0.006美元/分钟。 ","date":"2023-03-13","objectID":"/springboot-openai/:9:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"使用Whisper API进行音频翻译 除了音频转录，Whisper API还提供音频翻译端点 /audio/translations 。我也测试了这个特性。然而，我发现，尽管它说可以把音频翻译成英语，但我录了一个中文短语，并在应用程序中调用了 /audio/translations api，结果发现回应仍然是中文。我也用日语测试了这个api，它完整的翻译成了英语。这应该是一个bug。 ","date":"2023-03-13","objectID":"/springboot-openai/:10:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["java"],"content":"总结 与任何第三方REST API一样，将OpenAI API集成到Springboot中非常简单。 因此使用api开发自己的人工智能程序会变的非常便捷。 ","date":"2023-03-13","objectID":"/springboot-openai/:11:0","tags":["springboot","openai"],"title":"使用springboot整合OpenAI的Chatgpt api和Whisper api","uri":"/springboot-openai/"},{"categories":["书籍分享","区块链","did"],"content":"这是《Self-Sovereign Identity》(《身份自主权》中英文书籍) 分享","date":"2023-03-05","objectID":"/ssi_book/","tags":["Self-Sovereign Identity","SSI","身份自主权","did","区块链"],"title":"《Self-Sovereign Identity》(《身份自主权》中英文书籍)","uri":"/ssi_book/"},{"categories":["书籍分享","区块链","did"],"content":"百度网盘下载地址 链接：https://pan.baidu.com/s/1ZkE_goWKyTMtZPdyZXRp7A?pwd=b0m1 提取码：b0m1 因为网上没有找到中文书籍，使用了deepl机翻，翻译的排版不是很好，但是基本能看懂。 ","date":"2023-03-05","objectID":"/ssi_book/:1:0","tags":["Self-Sovereign Identity","SSI","身份自主权","did","区块链"],"title":"《Self-Sovereign Identity》(《身份自主权》中英文书籍)","uri":"/ssi_book/"},{"categories":["书籍分享","区块链","did"],"content":"内容简介 ​ Self-Sovereign Identity gives you a radical new perspective on how we represent ourselves in the world. This case study-driven book cuts through the jargon and hype to expose the amazing potential SSI offers for for security, privacy, identity, and even uprooting way the global economy works. SSI experts Drummond Reed and Alex Preukschat present a vision of the future, examining how SSI protocols will impact industries from banking through to government. You’ll get a clear mental model for how SSI works as you tour SSI-enabled eCommerce and eHealth applications and their advantages over current technologies. While you learn the philosophical and sociological concepts that underpin SSI, you’ll reach the book’s lightbulb moment: what this radical technology really means for the shape of our lives, our businesses, and our futures. what’s inside How SSI will affect your industry The essential technical and legal concepts of SSI The architecture of SSI software Emerging standards for SSI ​ 自我主权身份 “为您提供了一个关于我们如何在世界中代表自己的全新视角。这本以案例研究为导向的书突破了专业术语和炒作，揭示了SSI为安全、隐私、身份，甚至为全球经济运作方式提供的惊人潜力。SSI专家Drummond Reed和Alex Preukschat提出了未来的愿景，研究了SSI协议将如何影响从银行到政府的各个行业。当你参观SSI支持的电子商务和电子医疗应用以及它们相对于当前技术的优势时，你会对SSI如何工作有一个清晰的心理模型。在你学习支撑SSI的哲学和社会学概念的同时，你将迎来本书的闪光时刻：这项激进的技术对我们的生活、商业和未来的形态意味着什么。 书中内容 SSI将如何影响你的行业 SSI的基本技术和法律概念 SSI软件的架构 新兴的SSI标准 ","date":"2023-03-05","objectID":"/ssi_book/:2:0","tags":["Self-Sovereign Identity","SSI","身份自主权","did","区块链"],"title":"《Self-Sovereign Identity》(《身份自主权》中英文书籍)","uri":"/ssi_book/"},{"categories":["区块链","Go"],"content":"这是一个简单的默克尔树(Merkle tree)的Go实现","date":"2023-03-05","objectID":"/merkle_tree_go/","tags":["Merkle tree","Go"],"title":"默克尔树(Merkle tree)的Go实现","uri":"/merkle_tree_go/"},{"categories":["区块链","Go"],"content":"Merkle trees Merkle树是区块链技术的基本组成部分。它是由不同数据块的散列组成的数学数据结构，用作块中所有交易的摘要。 它还允许对大量数据中的内容进行有效和安全的验证。此结构有助于验证数据的一致性和内容。比特币和以太坊都使用Merkle树结构。Merkle树也被称为哈希树。 从根本上说，Merkle树是数据结构树，其中每个叶节点都用数据块的哈希标记，非叶节点用加密标记 其子节点标签的哈希值。叶节点是树中的最低节点。 ","date":"2023-03-05","objectID":"/merkle_tree_go/:0:1","tags":["Merkle tree","Go"],"title":"默克尔树(Merkle tree)的Go实现","uri":"/merkle_tree_go/"},{"categories":["区块链","Go"],"content":"原理 区块链中每个区块都会有一个 Merkle 树，它从叶子节点（树的底部）开始，一个叶子节点就是一个交易哈希。叶子节点的数量必须是双数，但是并非每个块都包含了双数的交易。如果一个块里面的交易数为单数，那么就将最后一个叶子节点（也就是 Merkle 树的最后一个交易，不是区块的最后一笔交易）复制一份凑成双数。 从下往上，两两成对，连接两个节点哈希，将组合哈希作为新的哈希。新的哈希就成为新的树节点。重复该过程，直到仅有一个节点，也就是树根。根哈希然后就会当作是整个块交易的唯一标示，将它保存到区块头，然后用于工作量证明。 ","date":"2023-03-05","objectID":"/merkle_tree_go/:0:2","tags":["Merkle tree","Go"],"title":"默克尔树(Merkle tree)的Go实现","uri":"/merkle_tree_go/"},{"categories":["区块链","Go"],"content":"代码实现 package main import ( \"bufio\" \"crypto/sha256\" \"fmt\" \"os\" \"strconv\" ) //默克尔树节点结构体 type Node struct { Index int Value string RootTree *MHTree } //默克尔树结构体 type MHTree struct { Length int Nodes []Node rootHash string } //获得默克尔树根节点哈希值 func (t *MHTree) GetRootHash() string { //不管是否存储，都重新计算哈希值 t.rootHash = t.Nodes[1].getNodeHash() return t.rootHash } //计算默克尔树中某个节点的哈希值 func (n *Node) getNodeHash() string { //叶子节点，则直接计算该节点Value的哈希值 if n.Value != \"\" { return calDataHash(n.Value) } //非叶子节点，则递归计算哈希值,其为2个子节点哈希值的哈希值123123123123 return calDataHash(n.RootTree.Nodes[n.Index*2].getNodeHash() + n.RootTree.Nodes[n.Index*2+1].getNodeHash() ) //计算数据的哈希值 func calDataHash(data string) string { hash := sha256.New() hash.Write([]byte(data)) return string(hash.Sum(nil)) } //从结构化文件创建默克尔树 func CreateMHTree(fileName string) MHTree { var tree MHTree //打开文件 file, err := os.Open(fileName) if err != nil { panic(err) } defer file.Close() //获取读取器 buf := bufio.NewReader(file) //读取首行，获得叶子节点数目（要求叶子节点数目为2的整数次幂 dataCountStr, _, _ := buf.ReadLine() dataCount, _ := strconv.Atoi(string(dataCountStr)) //判断幂次 level := 0 for i := 1; ; i++ { if 2\u003c\u003ci == dataCount { level = i break } } //创建默克尔树 //给非叶子节点赋值 for i := 1; i \u003c= 2\u003c\u003clevel-1; i++ { tree.Nodes[i].Index = i tree.Nodes[i].RootTree = \u0026tree } //读取文件数据，给叶子节点赋值 for i := 2 \u003c\u003c level; i \u003c tree.Length; i++ { str, _, _ := buf.ReadLine() tree.Nodes[i].Index = i tree.Nodes[i].RootTree = \u0026tree tree.Nodes[i].Value = string(str) } return tree } func main() { var fileName string fmt.Println(\"请输入原始数据文件名称\") fmt.Scanln(\u0026fileName) mhTree1 := CreateMHTree(fileName) fmt.Println(\"请输入比对数据文件名称\") fmt.Scanln(\u0026fileName) mhTree2 := CreateMHTree(fileName) hash1 := mhTree1.GetRootHash() hash2 := mhTree2.GetRootHash() if hash1 == hash2 { fmt.Println(\"用户没有改变数据\") } else { fmt.Println(\"用户改变了数据\") } } ","date":"2023-03-05","objectID":"/merkle_tree_go/:0:3","tags":["Merkle tree","Go"],"title":"默克尔树(Merkle tree)的Go实现","uri":"/merkle_tree_go/"},{"categories":["零知识"],"content":"零知识证明学习资源汇总 零知识证明技术是现代密码学三大基础之一，由 S.Goldwasser、S.Micali 及 C.Rackoff 在 20 世纪 80 年代初提出。早期的零知识证明由于其效率和可用性等限制，未得到很好的利用，仅停留在理论层面。直到近年来，零知识证明的理论研究才开始不断突破，同时区块链也为零知识证明创造了大展拳脚的机会，因而走进大众视野。 零知识证明这项“黑科技”随着它的热度逐渐增加，相关的学习资源也慢慢丰富起来了。但是由于，一方面零知识证明背后的原理颇为复杂，且内容繁多；另一方面，针对零知识证明的学习资源质量参差不齐，尚未形成系统。因此对绝大多数读者来说，学习零知识证明的难度依然很大。 本文收集了关于零知识证明的一些学习资料（包括科普文章，论文，开源仓库及相关学习网站等），并对这些资源进行了整理分析，希望能对大家有所帮助。 由于整理时间有限和笔者自身知识的局限性，文章存在不足之处，欢迎纠正、补充和探讨。 ","date":"2023-03-05","objectID":"/zk/:0:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"1. 故事中的零知识证明 初次接触零知识证明的小伙伴一定会问，究竟什么是零知识证明呢？它到底在做什么？ 推荐几篇适合小白的文章： 「推荐文章一」一个数独引发的惨案：零知识证明（Zero-Knowledge Proof） 推荐值：❤️❤️❤️❤️❤️ 难度值：⭐️ 这篇文章的作者是著名的 Ghost 和 Spectre 这两个协议的创始团队的领队 Aviv Zohar。文章非常接地气且通俗易懂，通过三个好朋友一起玩数独游戏的故事介绍了什么是零知识证明。 原文链接：https://medium.com/qed-it/the-incredible-machine-4d1270d7363a 中文翻译：https://zhuanlan.zhihu.com/p/34072069 另外这篇文章中引用了两篇介绍零知识证明的论文，也值得看一看。 「推荐文章二」How to explain zero-knowledge protocols to your children 推荐值：❤️❤️❤️ 难度值：⭐️ 这篇来自上个世纪的文章，正如它的标题一样，作者以给孩子讲故事的口吻，讲了一个阿里巴巴与四十大盗的故事，这个故事后来也成为了介绍零知识证明的经典故事。以故事的形式讲述零知识证明使得这篇文章理解起来也很简单。 原文链接：http://pages.cs.wisc.edu/~mkowalcz/628.pdf 中文翻译：https://blog.dreamerryao.wiki/archives/%E8%AF%91howtoexplainzero-knowledgeprotocolstoyourchildren 「推荐文章三」Cryptographic and Physical Zero-Knowledge Proof Systems for Solutions of Sudoku Puzzles 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 如何在不泄漏任何信息的前提下向别人证明你有一个数独问题的答案呢？同样这个问题也是介绍零知识证明的经典案例。论文中提出了使用一个零知识证明协议解决这个问题的方案，这篇论文相比较于前两篇文章，理论性更强一些，篇幅更长，协议的介绍更为详细，但总体来说还算比较好理解。 原文链接：http://www.wisdom.weizmann.ac.il/~naor/PAPERS/sudoku.pdf 「推荐文章四」Zero knowledge proofs: a tale of two friends 推荐值：❤️❤️ 难度值：⭐️⭐️ 与前面几篇文章类似，这篇文章也是通过讲故事的形式来向读者介绍零知识证明的。文中 Prover 要向 Verifier 证明其知道魔法的解法。这篇文章篇幅较短，内容理解起来难度较小。 原文链接：https://medium.com/hackernoon/zero-knowledge-proofs-a-tale-of-two-friends-d7a0ffac3185 「推荐文章五」Explain Like I’m 5: Zero Knowledge Proof (Halloween Edition) 推荐值：❤️❤️ 难度值：⭐️⭐️ 这同样是一篇讲故事的文章，哈哈~ 这篇文章讲述了一个糖果和百万富翁的故事（Candy bars and millionaires），文章同样篇幅较短，内容理解起来难度较小。 原文链接：https://medium.com/hackernoon/eli5-zero-knowledge-proof-78a276db9eff 兴许是因为如何解释零知识证明的问题并不简单，所以绝大部分入门级的科普文章都是从讲故事开始的。 ","date":"2023-03-05","objectID":"/zk/:1:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"2. 深入理解零知识证明 零知识证明技术涉及的知识点繁多，性质也各不相同。了解了什么是零知识证明以后，就需要对零知识证明更深刻的理解，推荐以下几篇零知识证明系列科普文。 「推荐文章六」零知识证明: 抛砖引玉 推荐值：❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️ 作者是 Zerocash 协议的创建者之一，密码学大神 Matthew Green[1]。这两篇文章几乎涵盖了学习零知识证明原理所有的基本概念，文章思路很清晰。 零知识证明: 抛砖引玉 第一篇文章主要从零知识证明的起源开始讲起，然后同样借助了地图三染色和 “时光机”来对零知识证明进行介绍。 原文链接：https://blog.cryptographyengineering.com/2014/11/27/zero-knowledge-proofs-illustrated-primer/ 中文翻译版本：https://ethfans.org/posts/zero-knowledge-proofs-illustrated-primer 零知识证明：抛砖引玉，Part-2 这篇文章在第一篇的基础上，进一步对零知识证明的三个性质：可靠性，完整性和零知识，展开介绍。另外还结合 Schnorr 协议介绍了交互式和非交互式的概念。 原文链接：https://blog.cryptographyengineering.com/2017/01/21/zero-knowledge-proofs-an-illustrated-primer-part-2/ 中文翻译版本：https://ethfans.org/posts/zero-knowledge-proofs-an-illustrated-primer-part-2 「推荐文章七」安比实验室零知识证明介绍系列文章 推荐值：❤️❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这个系列的作者是安比实验室创始人郭宇，文章与以往的零知识证明科普文章的不同之处就是它没有单独去讲解零知识的基本原理。而且结合更多的概念和原理，更透彻得将零知识证明技术涉及得诸多原理逐一进行讲解，文章专业性较强，还包含了作者大量的思考，但理解起来也较为直观易懂，非常适合想要深入理解零知识证明的小伙伴。 另外这个系列的文章还在持续更新中。 探索零知识证明系列一：初识「零知识」与「证明」 作为系列的第一篇，这篇文章首先介绍了「证明」的发展历程和「零知识」的作用，并举了一个地图三染色的例子，然后又对「信息」、「知识」和可满足电路的概念展开了介绍。 原文链接：https://sec-bit.github.io/blog/2019/07/31/zero-knowledge-and-proof/ 探索零知识证明系列二：从「模拟」理解零知识证明：平行宇宙与时光倒流 这篇文章介绍了零知识证明中的一个非常重要的概念——模拟（Simulator），「模拟」可以说是安全协议中核心的核心。文章中借助 “平行世界” 的假设去理解零知识读起来也非常有意思。 原文链接：https://sec-bit.github.io/blog/2019/08/06/understand-zero-knowledge-proof-by-simulator/ 探索零知识证明系列三：读心术：从零知识证明中提取「知识」 零知识证明有三个重要的性质：可靠性，完整性和零知识。这篇文章探讨了可靠性。文章解释了如何借助「抽取器」和时间倒流的超能力把 Alice 的「知识」完整地「抽取」出来，并可给出了一个与之相关攻击实例 —— ECDSA 签名攻击。 原文链接：https://sec-bit.github.io/blog/2019/08/28/extractor-and-proof-of-knowledge/ 探索零知识证明系列四：亚瑟王的「随机」挑战：从交互到非交互式零知识证明 这篇文章主要在讲零知识证明的信任根基——随机挑战。文章对零知识证明协议在两种不同的形式（交互式和非交互式）下随机挑战的方式进行了介绍。另外文章还对交互和非交互形式展开了介绍。 原文链接：https://sec-bit.github.io/blog/2019/11/01/from-interactive-zkp-to-non-interactive-zkp/ 「推荐文章八」零知识证明：一个略微严肃的科普 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️⭐️ 邓老师这篇“略微严肃”的科普，主要涉及两部分：1. 交互式证明的巨大威力；2. 零知识证明的定义和那些广泛流传的错误的例子 原文链接：https://zhuanlan.zhihu.com/p/29491567 「推荐文章九」Zero-Knowledge Proofs: A Layman’s Introduction 推荐值：❤️❤️ 难度值：⭐️⭐️ 这篇文章首先介绍了零知识证明协议中的三个参与者（Creator，Prover，Verifier）以及 Proofs 和 Verification的概念，并对 zkSNARK （一类零知识证明协议）和椭圆曲线的相关资料进行了介绍。 原文链接：https://blog.aventus.io/zero-knowledge-proofs-a-laymans-introduction-7020b93beeda 「推荐文章十」白话零知识证明（一） 推荐值：❤️❤️ 难度值：⭐️⭐️ 这篇来自秘猿科技的文章通过阿里巴巴的故事引出了零知识证明的一些概念，并对其进行了介绍。 原文链接：https://zhuanlan.zhihu.com/p/33189921 零知识证明涉及很多很有意思的思想和原理，都很值得探讨。在此不得不感叹于数学与密码学的精妙之处，也不得不钦佩密码学家们的厉害。 ","date":"2023-03-05","objectID":"/zk/:2:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"3. 零知识证明的发展 零知识证明的研究今年来一直有新的进展，密码学家们提出了各种不同的协议，推荐两篇文章介绍零知识证明研究的发展过程。 「推荐文章十一」区块链学习笔记 (1)：零知识证明的江湖 推荐值：❤️❤️❤️ 难度值：⭐️⭐️ 这篇文章讲了自 1895 年提出以来，零知识证明理论研究的发展过程，以及 zk-SNARKs 与零知识证明技术结合起来的发展过程。推荐给想了解零知识理论研究的发展过程的小伙伴。 原文链接：https://zhuanlan.zhihu.com/p/31651393 「推荐文章十二」Efficient Cryptographic Arguments and Proofs – Or How I Became a Fractional Monetary Unit 推荐值：❤️❤️❤️ 难度值：⭐️⭐️ 这篇文章来自UCL信息安全研究人员的博客 Bentham’s Gaze[2],文章介绍了自零知识证明提出以来，这群研究人员在理论研究上的研究历程及成果，包括知名的 bulletProof 和 zk-STARK 等。读完这篇文章相信会对大家深入理解零知识证明的诸多协议有所帮助。 原文链接：https://www.benthamsgaze.org/2019/05/22/efficient-cryptographic-arguments-and-proofs-or-how-i-became-a-fractional-monetary-unit/ 零知识证明迄今为止发展了三十多年，早期一直停留在理论层面，直到近十年才逐渐取得突破。随着越来越多研究人员的进场，相信这个领域未来还会有更多令人惊喜的成果。 ","date":"2023-03-05","objectID":"/zk/:3:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"4. zk-SNARKs 原理 作为零知识证明领域最知名的一类协议，zk-SNARKs 的理论研究和应用也最为广泛。推荐一些介绍 zk-SNARKs 的资料。 「推荐文章十三」V 神的 zk-SNARKs 科普文章 推荐值：❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️⭐️ V 神的这几篇文章应该算得上是流传最为广泛的 zk-SNARK 科普文了。不用多说，推荐阅读。 Quadratic Arithmetic Programs: from Zero to Hero 这篇文章详细介绍了 zk-SNARKs 的实现过程。文中将 zk-SNARKs 的实现分为以下几个步骤： computational problem —\u003e 电路 电路 —\u003e R1CS R1CS —\u003e QAP QAP —\u003e Linear PCP Linear PCP —\u003e Linear Interactive Proof Linear Interactive Proof —\u003e zkSNARK 原文链接：https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649 Exploring Elliptic Curve Pairings 这篇文章介绍了椭圆曲线配对。 原文链接：https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627 Zk-SNARKs: Under the Hood 这篇文章主要介绍了匹诺曹协议。 原文链接：https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6 「推荐文章十四」zcash 官方科普文 推荐值：❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️⭐️ 这个系列的文章来自 zCash 官方博客。首先介绍了零知识的基本概念以及其应用到 zcash 中的大致思路。随后 7 篇文章分别对 7 个关键点进行了详细介绍（同态隐藏，多项式盲验证，KCA，完整的多项式盲验证，计算到多项式的转换，匹诺曹协议以及椭圆曲线配对），推荐给想深入了解 zk-SNARKs 实现原理的小伙伴。 原文链接： What are zk-SNARKs?：https://z.cash/technology/zksnarks/ Explaining SNARKs Part I: Homomorphic Hidings https://electriccoin.co/blog/snark-explain/ Explaining SNARKs Part II: Blind Evaluation of Polynomials https://electriccoin.co/blog/snark-explain2/ Explaining SNARKs Part III: The Knowledge of Coefficient Test and Assumption https://electriccoin.co/blog/snark-explain3/ Explaining SNARKs Part IV: How to make Blind Evaluation of Polynomials Verifiable https://electriccoin.co/blog/snark-explain4/ Explaining SNARKs Part V: From Computations to Polynomials https://electriccoin.co/blog/snark-explain5/ Explaining SNARKs Part VI: The Pinocchio Protocol https://electriccoin.co/blog/snark-explain6/ Explaining SNARKs Part VII: Pairings of Elliptic Curves](https://electriccoin.co/blog/snark-explain7/ 中文翻译版本链接：https://www.jianshu.com/p/b6a14c472cc1、https://www.jianshu.com/p/92f54fc08d58 「推荐文章十五」Why and How zk-SNARK Works 推荐值：❤️❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️ 作者将其学习 zk-SNARK 的经验总结成了一份 PDF 文档并分成 8 篇文章发布到了 Medium 上。与大部分的 zk-SNARK 科普文不同，这个系列的文章没有直接开始讲 zk-SNARK，而是从最基本的数学原理讲起，讲解得非常细致，特别适合数学和密码学基础相对薄弱的小伙伴。 原文链接： PDF 完整版：https://arxiv.org/pdf/1906.07221.pdf Why and How zk-SNARK Works 1: Introduction \u0026 the Medium of a Proof：https://medium.com/@imolfar/why-and-how-zk-snark-works-1-introduction-the-medium-of-a-proof-d946e931160 Why and How zk-SNARK Works 2: Proving Knowledge of a Polynomial：https://medium.com/@imolfar/why-and-how-zk-snark-works-2-proving-knowledge-of-a-polynomial-f817760e2805 Why and How zk-SNARK Works 3: Non-interactivity \u0026 Distributed Setup：https://medium.com/@imolfar/why-and-how-zk-snark-works-3-non-interactivity-distributed-setup-c0310c0e5d1c Why and How zk-SNARK Works 4: General-Purpose Computation：https://medium.com/@imolfar/why-and-how-zk-snark-works-4-general-purpose-computation-dcdc8081ee42 Why and How zk-SNARK Works 5: Variable Polynomials：https://medium.com/@imolfar/why-and-how-zk-snark-works-5-variable-polynomials-3b4e06859e30 Why and How zk-SNARK Works 6: Verifiable Computation Protocol：https://medium.com/@imolfar/why-and-how-zk-snark-works-6-verifiable-computation-protocol-1aa19f95a5cc Why and How zk-SNARK Works 7: Constraints and Public Inputs：https://medium.com/@imolfar/why-and-how-zk-snark-works-7-constraints-and-public-inputs-e95f6596dd1c Why and How zk-SNARK Works 8: Zero-Knowledge Computation：https://medium.com/@imolfar/why-and-how-zk-snark-works-8-zero-knowledge-computation-f120339c2c55 「推荐文章十六」 zkSNARKs in a nutshell 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这篇文章对零知识证明做了总结，分成四个部分： 编码成一个多项式问题 简单随机抽样 同态（Homomorphic）编码 / 加密 零知识 文章首先介绍了零知识证明，然后又讲解了zk-SNARKs 的实现，最后分析了将零知识证明结合到以太坊上的作用和方式。 原文链接：https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/ 中文翻译版本：https://zhuanlan.zhihu.com/p/31780893 「推荐文章十七」Zero-knowledge proofs, a board game, and leaky abstractions: how I learned zk-SNARKs from scratch 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 作者坚持一个观点：学习新技能的一个很好的方法是用它建立一些东西。这篇文章就是在介绍作者是如何通过实现一个小的应用来学习 zk-SNARKs 的。文章主要介绍了作者的实现过程和他的思考，文中有很多好的经验时候大家学习。 原文链接：https://medium.com/@weijiek/how-i-lea","date":"2023-03-05","objectID":"/zk/:4:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"5. 零知识证明协议 零知识证明协议很多，每个协议的实现也各不相同，有些协议已经应用到了实际的领域，有些还在探索中。推荐几篇介绍不错的文章。 「推荐文章十九」STARKs 科普 推荐值：❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️⭐️ V 神的这个科普系列文章，非常详细得介绍了 STARKs 的实现，分成三个部分进行讲解。 原文链接： STARKs, Part I: Proofs with Polynomials：https://vitalik.ca/general/2017/11/09/starks_part_1.html 中文翻译版本：https://ethfans.org/posts/starks_part_1 STARKs, Part II: Thank Goodness It’s FRI-day：https://vitalik.ca/general/2017/11/22/starks_part_2.html 中文翻译版本：https://ethfans.org/posts/starks_part_2 STARKs, Part 3: Into the Weeds：https://vitalik.ca/general/2018/07/21/starks_part_3.html) 中文翻译版本：https://ethfans.org/posts/starks_part_3_1 中文翻译版本：https://ethfans.org/posts/starks_part_3_2 「推荐文章二十」 Understanding PLONK 推荐值：❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️⭐️ 这篇文章同样来自 V 神的博客，介绍了 PLONK 的工作原理。PLONK 是一种全新的零知识证明系统，支持通用或可更新的可信设置（trusted setup），作者是 Filecoin 母公司 Protocol Labs 的研究员 Ariel Gabizon 和以太坊隐私交易协议 Aztec Protocol 的两名研究人员 Zachary J. Williamson、Oana Ciobotaru。 原文链接：https://vitalik.ca/general/2019/09/22/plonk.html 中文翻译版本：https://www.8btc.com/article/486086 「推荐文章二十一」Groth09 笔记 推荐值：❤️❤️ 难度值：⭐️⭐️⭐️ 这篇文章作者huyuguang，文中对 Groth09 论文[4]的内容进行了总结，对大家学习 Groth09 有所帮助。 原文链接：https://github.com/huyuguang/zkpblog/blob/master/groth09.md 「推荐文章二十二」 零知识证明 - Groth16 算法介绍 推荐值：❤️❤️ 难度值：⭐️⭐️⭐️ Star Li 的这两篇文章主要从工程应用理解的角度介绍了 Groth16 算法的证明和验证过程，推荐给学习 Groth16 算法的小伙伴。 原文链接 零知识证明 - Groth16 算法介绍：https://mp.weixin.qq.com/s/SguBb5vyAm2Vzht7WKgzug 零知识证明 - 有关 Groth16 的zk证明的理解：https://mp.weixin.qq.com/s/x1ggw3VplXAIeL87D5bUfw 对于零知识证明各个协议介绍的文章还比较有限，随着应用的增多，相信这方面的文章也会越来越多。 ","date":"2023-03-05","objectID":"/zk/:5:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"6. 零知识证明在区块链领域的应用 零知识证明技术是随着区块链的发展逐渐走入大众视野的，目前零知识证明结合区块链的研究和应用也越来越多。 「推荐文章二十三」 一文读懂区块链中的零知识证明 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这篇来自BFTF技术社区联盟的文章介绍了零知识证明在 zcash 和门罗币上的应用。 原文链接：https://www.odaily.com/post/5133827 「推荐文章二十四」How to prove that you know something, without revealing it? Zero-knowledge proofs, ZCash, Ethereum. 推荐值：❤️❤️❤️ 难度值：⭐️⭐️ 这篇文章介绍了零知识证明在 Zcash 和以太坊上的应用。 原文链接：https://medium.com/hackernoon/how-to-prove-that-you-know-something-without-revealing-it-zero-knowledge-proofs-zcash-ethereum-43ce35d4d1c5 「推荐文章二十五」Zero-knowledge proofs, Zcash, and Ethereum 推荐值：❤️❤️❤️ 难度值：⭐️⭐️ 这篇文章介绍了零知识证明在 Zcash 和以太坊上的应用。 原文链接：https://blog.keep.network/zero-knowledge-proofs-zcash-and-ethereum-f6d89fa7cba8 「推荐文章二十六」零知识证明 - zk-SNARK应用场景分析 推荐值：❤️❤️❤️ 难度值：⭐️⭐️ 这篇文章介绍了零知识证明在 Zcash，Filecoin项目和 Loopring DEX 3.0 协议中的应用。 原文链接：https://mp.weixin.qq.com/s/9QccZtFcvGwne-NN4BBA5w 「推荐文章二十七」Zerocoin: making Bitcoin anonymous 推荐值：❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这篇文章介绍了 Zerocoin 协议是如何利用 zk-SNARKs 在区块链上实现匿名的。 原文链接：https://blog.cryptographyengineering.com/2013/04/11/zerocoin-making-bitcoin-anonymous/ 「推荐文章二十八」不是程序员也能看懂的ZCash零知识证明 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这篇文章使用比较通俗易懂的语言介绍了 zCash 如何利用零知识证明实现匿名交易的。 原文链接：https://zhuanlan.zhihu.com/p/24440530 「推荐文章二十九」 Monero to Become First Billion-Dollar Crypto to Implement ‘Bulletproofs’ Tech 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这篇文章介绍了 Monero 如何使用 Bulletproofs 技术实现隐私特性的。 原文链接：https://www.coindesk.com/monero-to-become-first-billion-dollar-crypto-to-implement-bulletproofs-tech 「推荐文章三十」 zkPoD:区块链，零知识证明与形式化验证，实现无中介、零信任的公平交易 推荐值：❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这是安比实验室今年发布的基于零知识证明的公平交易协议。 原文链接：https://mp.weixin.qq.com/s/TCYDfOAle0K3D69eBm6HNw 「推荐文章三十一」 零知识证明 - Loopring DEX 3.0 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这篇文章介绍了 Loopring DEX 3.0 协议的零知识证明部分实现原理。 原文链接：https://mp.weixin.qq.com/s/oTbzyqtc-TzJXbMafj28DQ 零知识证明的应用正在逐步增加，从最早的公链 zCash，Monero，到最近基于以太坊平台的 zkPoD, Loopring DEX 3.0应用等，零知识证明在区块链领域的应用将越来越多。 ","date":"2023-03-05","objectID":"/zk/:6:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"7. 零知识证明相关的技术和漏洞分析文章 零知识证明技术涉及的知识内容很多，在实际的应用场景中，零知识证明的实现还存在诸多的挑战，协议安全，性能等等问题都有可能限制其发展。这一节推荐一些技术分析和漏洞分析的文章。 「推荐文章三十二」 A Marlin is One of the Fastest SNARKs in the Ocean 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️⭐️ 这篇文章来自于博客 Bentham’s Gaze，文章观点认为 Marlin 是最快的 SNARKs 方案，并将其与其它的方案进行了比较。 原文链接：https://www.benthamsgaze.org/2019/09/19/a-marlin-is-one-of-the-fastest-snarks-in-the-ocean/ 「推荐文章三十三」How to do Zero-Knowledge from Discrete-Logs in under 7kB 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这篇文章同样来自于博客 Bentham’s Gaze，文章介绍了Groth09 论文中的优化方案。 原文链接：https://www.benthamsgaze.org/2016/10/25/how-to-do-zero-knowledge-from-discrete-logs-in-under-7kb/ 「推荐文章三十四」zkSNARK 合约「输入假名」漏洞致众多混币项目爆雷 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这篇文章的作者是安比实验室 p0n1，文章介绍了大量零知识证明项目由于错误地使用了某个 zkSNARKs 合约库，引入「输入假名 (Input Aliasing) 」漏洞，可导致伪造证明、双花、重放等攻击行为发生，且攻击成本极低。 原文链接：https://sec-bit.github.io/blog/page/2/ 「推荐文章三十五」硬核！360高级安全专家彭峙酿以Zcash为例，谈零知识性证明的安全和隐私问题 推荐值：❤️❤️❤️❤️ 难度值：⭐️⭐️⭐️ 这篇文章是对360高级安全专家彭峙酿博士在 CCF 会议上分享报告的整理。报告中介绍了比特币的隐私问题，零知识证明技术，zk-SNARKs，以及多个实现漏洞。报告干货满满。 原文链接：https://zhuanlan.zhihu.com/p/87690026 「推荐文章三十六」零知识证明中所涉及的有限域 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️⭐️ 有限域的计算是实现零知识证明协议的一个非常重要的环境，这篇文章对零知识证明中所涉及导的有限域的知识进行了介绍，非常有用。 原文链接：https://github.com/huyuguang/zkpblog/blob/master/有限域.md ","date":"2023-03-05","objectID":"/zk/:7:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"8. 零知识证明开源仓库及介绍 下面介绍几个热度比较高的零知识证明实现仓库及其源码分析文章，很多的零知识项目都是基于这几个仓库的代码做的。 libsnark libsnark 是实现一个 C++ 版本的零知识证明库。 仓库链接：https://github.com/scipr-lab/libsnark 「推荐文章三十七」零知识证明 - libsnark源代码分析 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 原文链接：https://mp.weixin.qq.com/s/UHqpfl6ImVwa4HtsiksqJA 「推荐文章三十八」零知识证明实战：libsnark 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️ 原文链接：https://zhuanlan.zhihu.com/p/46477111 bellman bellman是Zcash团队用Rust语言开发的一个zk-SNARK软件库，实现了Groth16 算法。 仓库链接：https://github.com/zkcrypto/bellman 「推荐文章三十九」零知识证明 - bellman源码分析 推荐值：❤️❤️ 难度值：⭐️⭐️⭐️ 原文链接：https://github.com/zcash/librustzcash/tree/master/bellman snarkjs libsnark 是实现一个 javascript 版本的零知识证明库，实现了 Groth16。 仓库链接：https://github.com/iden3/snarkjs ","date":"2023-03-05","objectID":"/zk/:8:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"9. 零知识证明相关论文 下面介绍一下零知识证明相关的学术论文，深入学习零知识证明研究成果的小伙伴可以去阅读以下的这些论文。 推荐值：❤️❤️❤️ 难度值：⭐️⭐️⭐️⭐️⭐️ 1985 年，零知识证明技术首次被提出 原文链接：The Knowledge Complexity of Interactive Proof Systems BulletProof Gro09 提出了一种证明“向量内积”的方法： 原文链接：https://link.springer.com/chapter/10.1007/978-3-642-03356-8_12 BCC+16 找到了一种将算数电路编码为向量的方法，从而把电路可满足性的证明转化为向量内积的证明： 原文链接：https://eprint.iacr.org/2016/263 BulletProof继续改进了这种方案： 原文链接：https://eprint.iacr.org/2017/1066 zkSNARKs with trusted setup Groth10 引入了preprocessing的步骤，通过可信第三方生成Common Reference String来实现无交互证明: 原文链接：https://link.springer.com/chapter/10.1007/978-3-642-17373-8_19 GGPR13 引入了另一种算数电路编码方式，即Quadratic Arithmetic Program(QAP)，大大提升了证明的效率: 原文链接：https://eprint.iacr.org/2012/215 Pinocchio 和 Groth16 等是在此基础上的改进: 原文链接：https://eprint.iacr.org/2013/279 原文链接：https://eprint.iacr.org/2016/260 Ligero: Lightweight Sublinear Arguments Without a Trusted Setup: 原文链接：https://acmccs.github.io/papers/p2087-amesA.pdf PLONK: 原文链接：https://eprint.iacr.org/2019/953 Marlin 原文链接：https://eprint.iacr.org/2019/1047.pdf Sonic 原文链接：https://eprint.iacr.org/2019/099 Libra 原文链接：https://eprint.iacr.org/2019/317 Hyrax 原文链接：https://eprint.iacr.org/2017/1132.pdf zk-STARKs 原文链接：https://eprint.iacr.org/2018/046 ","date":"2023-03-05","objectID":"/zk/:9:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"10. 零知识证明学习资料推荐网站 awesome-zero-knowledge-proofs 推荐值：❤️❤️❤️❤️ 这是一个 Github 仓库，收录了一系列零知识证明的学习资料 链接：https://github.com/matter-labs/awesome-zero-knowledge-proofs Zero-Knowledge Proofs 推荐值：❤️❤️❤️❤️ 这个网站也收录了一系列零知识证明的学习资料，相对来说学术性更强一些。 链接：https://zkp.science zkproof 推荐值：❤️❤️❤️❤️ ZKProof.org 是为规范零知识证明的使用而形成的一个组织，它的网站上有大量关于零知识证明的资料。 链接：https://zkproof.org/ benthamsgaze.org 推荐值：❤️❤️❤️ 这是一个来自UCL信息安全研究人员组成的团队的博客，它的博客上会经常发布一些零知识证明的文章。 链接：https://www.benthamsgaze.org ","date":"2023-03-05","objectID":"/zk/:10:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":["零知识"],"content":"参考文献 [1] https://isi.jhu.edu/~mgreen/ [2] https://www.benthamsgaze.org/about [3] https://zhuanlan.zhihu.com/p/31651393 [4] https://link.springer.com/chapter/10.1007/978-3-642-03356-8_12 [5] https://github.com/matter-labs/awesome-zero-knowledge-proofs [6] https://zkp.science/ [7] https://zhuanlan.zhihu.com/p/89386868?utm_source=wechat_session\u0026utm_medium=social\u0026utm_oi=26765481213952 ","date":"2023-03-05","objectID":"/zk/:11:0","tags":["零知识"],"title":"零知识学习资料收集汇总","uri":"/zk/"},{"categories":null,"content":"博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 ","date":"2023-02-20","objectID":"/first_post/:0:0","tags":null,"title":"我的第一篇文章","uri":"/first_post/"}]