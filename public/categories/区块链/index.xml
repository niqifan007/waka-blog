<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>区块链 - 分类 - waka&#39;s blog</title>
    <link>http://blog.579878700.xyz/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/</link>
    <description>区块链 - 分类 - waka&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 06 Apr 2023 17:46:33 &#43;0800</lastBuildDate><atom:link href="http://blog.579878700.xyz/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="self" type="application/rss+xml" /><item>
  <title>零知识机器学习（ZKML）简介</title>
  <link>http://blog.579878700.xyz/zkml/</link>
  <pubDate>Thu, 06 Apr 2023 17:46:33 &#43;0800</pubDate>
  <author>map[avatar:/images/avatar.jpg email:&lt;nil&gt; link:&lt;nil&gt; name:waka]</author>
  <guid>http://blog.579878700.xyz/zkml/</guid>
  <description><![CDATA[<h1 id="零知识机器学习zkml简介">零知识机器学习（ZKML）简介</h1>
<p>Zero-Knowledge 机器学习（ZKML）是最近正在密码学界引起轰动的一个研究和开发领域。但它是什么，有什么用处呢？首先，让我们把这个术语分解成它的两个组成部分，并解释一下它们是什么。</p>
<h2 id="什么是-zk">什么是 ZK？</h2>
<p>零知识证明是一种密码协议，其中一方（证明者）可以向另一方（验证者）证明一个给定的陈述是真实的，而不泄露除该陈述为真以外的任何附加信息。这是一个正在各个方面取得巨大进展的研究领域，涵盖了从研究到协议实施和应用的所有方面。</p>
<p>ZK 提供的两个主要“原语”（或者说构建块）是能够为一组给定的计算创建具有计算完整性证明的能力，其中证明比执行计算本身要容易地多。（我们称这种属性为“简洁性”）。ZK 证明也提供了隐藏计算中某些部分同时保持计算正确性的选项。（我们称这种属性为“零知识性”）。</p>
<p><strong>生成零知识证明需要非常大的计算量，大约比原始计算贵 100 倍</strong>。这意味着，在某些情况下由于最佳硬件上生成它们所需的时间使其不切实际，因此不能计算零知识证明。</p>
<p>然而，在近年来密码学、硬件和分布式系统领域的进步已经使零知识证明成为了越来越强大的计算可行的选择。这些进展已经为可以使用计算密集型证明的协议的创建提供了可能，从而扩大了新应用程序的设计空间。</p>
<p><strong>ZK 使用案例</strong></p>
<p>零知识密码学是 Web3 空间中最流行的技术之一，因为它允许开发人员构建可扩展和/或私有的应用程序。以下是一些实践中如何使用它的示例（尽管请注意，这些项目中许多都还在进行中）：</p>
<p><strong>1.通过 ZK rollups 扩展以太坊</strong></p>
<ul>
<li>Starknet</li>
<li>Scroll</li>
<li>Polygon Zero，Polygon Miden，Polygon zkEVM</li>
<li>zkSync</li>
</ul>
<p><strong>2.构建保护隐私的应用程序</strong></p>
<ul>
<li>Semaphore</li>
<li>MACI</li>
<li>Penumbra</li>
<li>Aztec Network</li>
</ul>
<p><strong>3.身份原语和数据来源</strong></p>
<ul>
<li>WorldID</li>
<li>Sismo</li>
<li>Clique</li>
<li>Axiom</li>
</ul>
<p><strong>4.第一层协议</strong></p>
<ul>
<li>Zcash</li>
<li>Mina</li>
</ul>
<p>随着 ZK 技术的成熟，我们相信将会出现新的应用程序的爆发，因为构建这些应用程序所使用的工具将需要更少的领域专业知识，对于开发人员来说将会更加容易使用。</p>
<h2 id="zkml-的动机和当前的努力">ZKML 的动机和当前的努力</h2>
<p>我们生活在一个世界上，<strong>AI/ML 生成的内容越来越难以与人类生成的内容区分开来</strong>。零知识密码学将使我们能够做出这样的声明：“给定一段内容 C，它是由模型 M 应用于一些输入 X 生成的。”我们将能够验证某个输出是否是由大型语言模型（如 chatGPT）或文本到图像模型（如 DALL-E 2）等任何其他我们为其创建了零知识电路表示的模型所生成的。这些证明的零知识属性将使我们能够根据需要也隐藏输入或模型的某些部分。一个很好的例子是在一些敏感数据上应用机器学习模型，在不透露输入到第三方的情况下，用户可以知道他们的数据在模型推理后的结果（例如，在医疗行业）。</p>
<p>注：当我们谈论 ZKML 时，我们是指创建 ML 模型推理步骤的零知识证明，而不是关于 ML 模型训练（它本身已经非常计算密集）。目前，现有技术水平的零知识系统加上高性能硬件仍然相差几个数量级，无法证明当前可用的大型语言模型（LLMs）等庞大的模型，但是在创建较小模型的证明方面已经取得了一些进展。</p>
<p>我们对零知识密码学在为 ML 模型创建证明的上下文中的现有技术水平进行了一些研究，并创建了一个聚合相关研究、文章、应用程序和代码库的文章集。ZKML 的资源可以在 GitHub 上的 ZKML 社区的 <a href="https://github.com/zkml-community/awesome-zkml"target="_blank" rel="external nofollow noopener noreferrer">awesome-zkml<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 存储库中找到。</p>
<p><a href="https://www.moduluslabs.xyz/"target="_blank" rel="external nofollow noopener noreferrer">Modulus Labs<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 团队最近发布了一篇名为“<a href="https://medium.com/@ModulusLabs/chapter-5-the-cost-of-intelligence-da26dbf93307"target="_blank" rel="external nofollow noopener noreferrer">智能的成本<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>”的论文，其中对现有的 ZK 证明系统进行了基准测试，并列举了不同大小的多个模型。目前，使用像 <a href="https://polygon.technology/blog/plonky2-a-deep-dive"target="_blank" rel="external nofollow noopener noreferrer">plonky2 <i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>这样的证明系统，在强大的 AWS 机器上运行 50 秒左右，可以为约 1800 万个参数的模型创建证明。以下是该论文中的一张图表：</p>
<p>另一个旨在改进 ZKML 系统技术水平的倡议是 Zkonduit 的 <a href="https://github.com/zkonduit/ezkl"target="_blank" rel="external nofollow noopener noreferrer">ezkl<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 库，它允许您创建对使用 ONNX 导出的 ML 模型的 ZK 证明。这使得任何 ML 工程师都能够为他们的模型的推理步骤创建 ZK 证明，并向任何正确实现的验证器证明输出。</p>
<p>有几个团队正在改进 ZK 技术，为 ZK 证明内部发生的操作创建优化硬件，并针对特定用例构建这些协议的优化实现。随着技术的成熟，更大的模型将在较不强大的机器上短时间内进行 ZK 证明。我们希望这些进展将使新的 ZKML 应用程序和用例得以出现。</p>
<a class="lightgallery" href="https://hx24-prod.mars-block.com/image/crawler/2023/04/06/1680766766002460.jpg" data-thumbnail="https://hx24-prod.mars-block.com/image/crawler/2023/04/06/1680766766002460.jpg" data-sub-html="<h2>https://hx24-prod.mars-block.com/image/crawler/2023/04/06/1680766766002460.jpg</h2>"></a>
<h2 id="潜在的使用案例">潜在的使用案例</h2>
<p>为了确定 ZKML 是否适用于特定的应用，我们可以考虑 ZK 密码学的特性将如何解决与机器学习相关的问题。这可以用一个 Venn 图来说明：</p>
<a class="lightgallery" href="https://hx24-prod.mars-block.com/image/crawler/2023/04/06/1680766766002404.jpg" data-thumbnail="https://hx24-prod.mars-block.com/image/crawler/2023/04/06/1680766766002404.jpg" data-sub-html="<h2>https://hx24-prod.mars-block.com/image/crawler/2023/04/06/1680766766002404.jpg</h2>"></a>
<p>定义：</p>
<p><strong>1.Heuristic optimization</strong><a href="https://en.wikipedia.org/wiki/Heuristic_%28computer_science%29"target="_blank" rel="external nofollow noopener noreferrer"><strong>启发式优化</strong><i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>—— 一种问题解决方法，它使用经验法则或“启发式”来找到艰难的问题的好解决方案，而不是使用传统的优化方法。启发式优化方法旨在在相对的重要性和优化难度下，在合理的时间内找到好的或“足够好”的解决方案，而不是尝试找到最优解决方案。</p>
<p><strong>2.FHE ML</strong><a href="https://en.wikipedia.org/wiki/Homomorphic_encryption"target="_blank" rel="external nofollow noopener noreferrer">全同态加密<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>—— 完全同态加密ML允许开发人员以保护隐私的方式训练和评估模型；然而，与ZK证明不同，没有办法通过密码学方式证明所执行的计算的正确性。</p>
<ul>
<li>像 <a href="https://www.zama.ai/"target="_blank" rel="external nofollow noopener noreferrer">Zama.ai<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>这样的团队正在从事这个领域的工作。</li>
</ul>
<p><strong>3.ZK vs Validity</strong> —— 在行业中，这些术语通常被互换使用，因为有效性证明是ZK证明，不会隐藏计算或其结果的某些部分。在ZKML的上下文中，大多数当前的应用程序都利用了ZK证明的有效性证明方面。</p>
<p><strong>4.Validity ML</strong> —— ZK证明ML模型，在其中没有计算或结果被保密。它们证明计算的正确性。</p>
<p>以下是一些潜在的 ZKML 用例示例：</p>
<p>1.计算完整性（有效性 ML）</p>
<ul>
<li>Modulus Labs<a href="https://www.moduluslabs.xyz/"target="_blank" rel="external nofollow noopener noreferrer">模量实验室<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li>基于链上可验证的 ML 交易机器人 - <a href="https://github.com/Modulus-Labs/RockyBot"target="_blank" rel="external nofollow noopener noreferrer">RockyBot<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
</ul>
<p>自我改进视觉区块链（示例）：</p>
<ul>
<li>增强 Lyra 金融期权协议 AMM 的智能特性<a href="https://www.lyra.finance/"target="_blank" rel="external nofollow noopener noreferrer">Lyra 金融期权协议 AMM<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></li>
<li>为 <a href="https://www.astraly.xyz/"target="_blank" rel="external nofollow noopener noreferrer">Astraly<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>  创建透明的基于 AI 的声誉系统（ZK oracle）</li>
<li>使用<a href="https://aztec.network/"target="_blank" rel="external nofollow noopener noreferrer"> ML for Aztec Protocol<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>（具有隐私功能的 zk-rollup）致力于合同级合规工具所需的技术突破。</li>
</ul>
<p>2.<a href="https://twitter.com/daniel_d_kang/status/1582519854405255168?s=20&amp;t=16FXZixQvD5G_B9IFVzmaA"target="_blank" rel="external nofollow noopener noreferrer">机器学习即服务<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>(MLaaS) 透明；</p>
<p>3.ZK 异常/欺诈检测：</p>
<ul>
<li>这种应用场景使得可创建针对<a href="https://blog.trailofbits.com/2020/05/21/reinventing-vulnerability-disclosure-using-zero-knowledge-proos/"target="_blank" rel="external nofollow noopener noreferrer">允许为可利用性<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>/欺诈的 ZK 证明成为可能。异常检测模型可以在智能合约数据上进行训练，并由 DAOs 同意作为有趣的度量标准，以便能够自动化安全程序，如更主动、预防性地暂停合约。已有初创企业正在研究在智能合约环境中使用 ML 模型进行安全目的的方法，因此 ZK 异常检测证明似乎是自然的下一步。</li>
</ul>
<p>4.ML 推理的通用有效性证明：能够轻松证明和验证输出是给定模型和输入对的乘积。</p>
<p>5.隐私 (ZKML)。</p>
<p>6.去中心化的 <a href="https://www.kaggle.com/"target="_blank" rel="external nofollow noopener noreferrer">Kaggle<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>：证明模型在某些测试数据上的准确率大于 x%，而不会显示权重。</p>
<p>7.隐私保护推理：将对私人患者数据的医疗诊断输入模型，并将敏感的推理（例如，癌症测试结果）发送给患者。（来源：<a href="https://eprint.iacr.org/2020/584.pdf"target="_blank" rel="external nofollow noopener noreferrer">vCNN 论文<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>，第 2/16 页）</p>
<p>8.Worldcoin：</p>
<ul>
<li><strong>IrisCode 的可升级性</strong>：<a href="https://id.worldcoin.org/"target="_blank" rel="external nofollow noopener noreferrer">World ID<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a> 用户将能够在他们的移动设备的加密存储中自我保管其生物特征，下载用于生成 IrisCode 的 ML 模型并在本地创建零知识证明，以证明其 IrisCode 已成功创建。这个 IrisCode 可以被无需许可地插入注册的 Worldcoin 用户之一，因为接收的智能合约可以验证零知识证明，从而验证 IrisCode 的创建。这意味着，如果 Worldcoin 将来升级机器学习模型以一种破坏与其之前版本兼容性的方式创建 IrisCode，用户就不必再次去 Orb，而可以在设备上本地创建这个零知识证明。</li>
<li><strong>Orb 安全性</strong>：目前，Orb 在其受信任的环境中执行几个欺诈和篡改检测机制。然而，我们可以创建一个零知识证明，表明这些机制在拍摄图像和生成 IrisCode 时是活动的，以便为 Worldcoin 协议提供更好的活体保证，因为我们可以完全确定这些机制在整个 IrisCode 生成过程中都将运行。</li>
</ul>
<p>总之，ZKML 技术有着广泛的应用前景，并且正在快速发展。随着越来越多的团队和个人加入到这个领域，我们相信 ZKML 的应用场景将会更加多样化和广泛化。</p>]]></description>
</item>
<item>
  <title>在超级账本Hyperledger Fabric中开发智能合约遇到的问题</title>
  <link>http://blog.579878700.xyz/fabric_bug/</link>
  <pubDate>Wed, 22 Mar 2023 16:11:51 &#43;0800</pubDate>
  <author>map[avatar:/images/avatar.jpg email:&lt;nil&gt; link:&lt;nil&gt; name:waka]</author>
  <guid>http://blog.579878700.xyz/fabric_bug/</guid>
  <description><![CDATA[<h2 id="1-不要尝试获取节点本地的时间作为key或value的值">1. 不要尝试获取节点本地的时间作为key或value的值</h2>
<p>即使每个节点的本地的时间系统是经过校对一致的，但同一个交易在每个节点上执行的时间点不一定是相同的。如果使用time.now().unix()来取节点本地的时间作为key或value的值，会导致每个节点执行同一个交易的结果不一致，从而造成交易失败。正确的做法是使用函数GetTxTimestamp()来获取交易的时间。每个节点通过函数GetTxTimestamp()来获取到的交易时间是相同的<br>
例子：<br>
t, err := stub.GetTxTimestamp()<br>
t.Seconds // 交易的时间，unix时间戳，精确到秒<br>
t.Nanos// 交易的时间，unix时间戳，精确到纳秒<br>
time.Unix(t.Seconds, int64(t.Nanos)).UnixNano() / 1e6 // 交易的时间，unix时间戳，精确到毫秒</p>
<p>但需要注意的是，每个节点通过函数GetTxTimestamp()来获取到的交易时间是相同的，但它取到的时间是客户端创建交易时的本地时间。如果客户端的本地时间没有校准的话，GetTxTimestamp()获取到的交易时间也是不准确的。</p>
<h2 id="2-在同一个区块里多笔交易对同一键进行更新">2. 在同一个区块里多笔交易对同一键进行更新</h2>
<p>对同一键进行更新的一个或多笔交易打包到同一块中，只有第1笔交易会成功，后面的交易会失败。相关的原因是：在一个区块里的多笔交易，只有在区块被提交后才会真正生效。而每一个键值都有版本号，假设一个键“key_1”在本个区块提交前的版本号为9，然后在本个区块里有2笔交易分别更新键&quot;key_1&quot;的值为&quot;123&quot;和&quot;456&quot;。那么当第1笔交易更新键“key_1”的值时，键&quot;key_1&quot;的版本号在本个区块里将更新为10，但在本区块未提交前，真正生效的版本号还是9。而当执行第2笔交易时，该交易读取到键&quot;key_1&quot;的版本号还是9，这样第2笔交易还是把键&quot;key_1&quot;的版本号更新为10，这样系统会判断为“双花”行为，从而引起冲突，导致只有第1笔交易会执行成功，第2笔交易执行失败。具体可以参考这篇文章 <a href="https://learnblockchain.cn/article/620"target="_blank" rel="external nofollow noopener noreferrer">https://learnblockchain.cn/article/620<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br>
简单地说，在同一个区块里多笔交易对同一键进行PutState()更新时，只有一笔交易是成功的，其它的交易会出现 MVCC_READ_CONFLICT报错。<br>
因此，试图在fabric合约里创建全局的计数器是一件不可靠的事情。</p>
<h2 id="3-在同一个区块里多笔交易先后对同一个键进行更新和读取">3. 在同一个区块里多笔交易先后对同一个键进行更新和读取</h2>
<p>假设在一个区块里有2笔交易，第1笔交易对键&quot;key_1&quot;值更新为&quot;123&quot;，第2笔交易尝试读取键&quot;key_1&quot;的值，结果第2笔交易读键&quot;key_1&quot;的值结果为空。原因上面已经提及到，一个区块里的多笔交易，只有在区块被提交后才会真正生效。</p>
<h2 id="4-在一个方法内对同一个键先写后读">4. 在一个方法内对同一个键先写后读</h2>
<p>在一个方法内对同一个键先进行写键值（putState()），然后再进行读键值（getState()），会发现前面的putState操作没有生效，原因也是同前面一样的道理</p>
<h2 id="5-尝试通过合约使用加密算法对信息进行加密">5. 尝试通过合约使用加密算法对信息进行加密</h2>
<p>有些加密算法对同样内容的信息进行加密，有可能每次加密的结果是不一样的。例如：RSA公钥对同一数据加密，每次的结果都不一样。这样会导致不同的节点执行加密的结果不一样，从而导致提交的内容不一致，造成交易失败</p>
<h2 id="6-没有了解query和invoke的合约函数调用方式">6. 没有了解query和invoke的合约函数调用方式</h2>
<p>超级账本调用合约函数的方式有2种：query和invoke<br>
通过query方式调用合约函数，只能查询链上数据，不能向链上写数据，并且不产生交易<br>
通过invoke方式调用合约函数，可以向链上写数据，并产生交易</p>
<p>如果一个合约函数里调用了PutState()操作，但是通过query方式来调用该合约函数，虽然不会报错，但PutState()操作实际没有生效，世界状态不会被改变</p>
<p>如果一个合约函数里没有调用PutState()操作，但是通过invoke方式来调用该合约函数，虽然不会报错，但却会产生交易</p>
<h2 id="7-使用couchdb在使用select语句时没有对select的字段建立索引">7. 使用CouchDB，在使用select语句时没有对select的字段建立索引</h2>
<p>超级账本可以使用Leveldb或CouchDB。如果要支持富查询，一般会选择使用CouchDB。CouchDB可以支持类似于SQL的select语句来实现富查询。但是CouchDB的效率并不高，在不建立索引的情况下，可能对2-3万条的数据使用select语句就会导致查询非常耗时，从而导致合约函数的执行超时而失败。而对于传统的关系型数据库，2-3万条的数据量，在不建立索引的情况下，对查询的影响不是很明显。</p>
<p>例如下面的select语句：<br>
&ldquo;{&ldquo;selector&rdquo;:{&ldquo;StudentAge&rdquo;:{&quot;$lte&rdquo;: 10}, &ldquo;sort&rdquo;:[{&ldquo;RegisterTime&rdquo;: &ldquo;asc&rdquo;}]}}&quot;</p>
<p>最好就需要对字段StudentAge和RegisterTime建立索引。</p>
<p>想知道CouchDB在执行一条查询语句究竟有没有使用索引，用了哪些索引，可以通过向CouchDB发送post请求的方法，通过返回的response来查看使用了哪些索引。具体可参考下面的链接<br>
<a href="https://docs.couchdb.org/en/latest/api/database/find.html#db-explain"target="_blank" rel="external nofollow noopener noreferrer">https://docs.couchdb.org/en/latest/api/database/find.html#db-explain<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br>
1.3.8. /db/_explain 这一节的内容</p>
<p>具体的操作可以通过postman来实现，<br>
post的地址如<a href="http://127.0.0.1:5984/member_goods/_explain"target="_blank" rel="external nofollow noopener noreferrer">http://127.0.0.1:5984/member_goods/_explain<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a><br>
发送的body就是查询select语句的内容，<br>
注意header里需要配置一个KeyValue Content-Type:application/json</p>
<h2 id="8-使用couchdb在使用select语句时尽量避免使用sort进行排序">8. 使用CouchDB，在使用select语句时尽量避免使用sort进行排序</h2>
<p>sort排序会严重消耗查询时间，容易造成查询超时，应尽量避免使用。使用sort语句，必须对sort语句中涉及的字段创建索引，否则会报错。</p>
<h2 id="9搭建fabric区块链浏览器的坑">9.搭建Fabric区块链浏览器的坑</h2>
<p>搭建Fabric区块链浏览器的时，如果之前曾经在同一台机器上使用不同的用户证书搭建过Fabric区块链浏览器，那么在同一台机器上使用新的用户证书搭建Fabric区块链浏览器时，一定要运行下面的命令清除之前的容器服务里的volume残留值：<br>
docker-compose down -v</p>
<p>详细可以参考这篇文章<br>
<a href="https://blog.csdn.net/lyz19961221/article/details/118576529"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/lyz19961221/article/details/118576529<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>
<h2 id="10避免fabric的智能合约函数陷入死循环">10.避免Fabric的智能合约函数陷入死循环</h2>
<p>合约函数陷入死循环，不但会导致本次合约函数执行超时，而且后面会导致无法执行其它合约函数的问题，后果非常严重，详细可以参考这篇文章<br>
<a href="https://zhuanlan.zhihu.com/p/572782459"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/572782459<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a></p>]]></description>
</item>
<item>
  <title>solidity动态数组的增删改查</title>
  <link>http://blog.579878700.xyz/solidity_curd/</link>
  <pubDate>Fri, 17 Mar 2023 00:35:21 &#43;0800</pubDate>
  <author>map[avatar:/images/avatar.jpg email:&lt;nil&gt; link:&lt;nil&gt; name:waka]</author>
  <guid>http://blog.579878700.xyz/solidity_curd/</guid>
  <description><![CDATA[<h2 id="数组类型">数组类型</h2>
<p>Solidity支持两种数组: 静态数组和动态数组。</p>
<p>又分<code>storage</code>与<code>memory</code>型数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">uint[] memory list;
</span></span><span class="line"><span class="cl">//变长memory数组，使用前必须确定长度
</span></span><span class="line"><span class="cl">list =new uint[](a);
</span></span><span class="line"><span class="cl">//然后再使用，一般用在函数内
</span></span><span class="line"><span class="cl">memory型数组不能使用pop,push也不能修改length
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="静态数组">静态数组</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 固定长度为2的静态数组定义
</span></span><span class="line"><span class="cl">uint[2] fixedArray;
</span></span><span class="line"><span class="cl">//定长数组实例化
</span></span><span class="line"><span class="cl">fixedArray = [4, 6];
</span></span></code></pre></td></tr></table>
</div>
</div><p>静态数组不可新增元素，但可修改现有元素的值。</p>
<h3 id="动态数组">动态数组</h3>
<p>动态数组，长度不固定，可以动态添加元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//声明
</span></span><span class="line"><span class="cl">uint[] dynamicArray;
</span></span><span class="line"><span class="cl">//初始化，这里实例化一个长度为2的数组，值为0。
</span></span><span class="line"><span class="cl">dynamicArray = new uint[](2);
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-solidity" data-lang="solidity"><span class="line"><span class="cl"><span class="c1">// SPDX-License-Identifier: MIT
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">pragma solidity</span> <span class="o">^</span><span class="mi">0</span><span class="p">.</span><span class="mi">8</span><span class="p">.</span><span class="mi">9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">library</span> <span class="n">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">push</span><span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_nums</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">_num</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">assembly</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 在可变数组的 末尾追加 一个value (_num)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">mstore</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="n">_nums</span><span class="p">,</span> <span class="nf">mul</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nf">mload</span><span class="p">(</span><span class="n">_nums</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="mh">0x20</span><span class="p">)),</span> <span class="n">_num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 可变数组的length 加 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">mstore</span><span class="p">(</span><span class="n">_nums</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="nf">mload</span><span class="p">(</span><span class="n">_nums</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// 0x40 是空闲内存指针的预定义位置 (value 为 空闲指针开始位)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="nf">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">),</span> <span class="mh">0x20</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">pop</span><span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_nums</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">num_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">assembly</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 取出可变数组的最后一个value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">num_</span> <span class="o">:=</span> <span class="nf">mload</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="n">_nums</span><span class="p">,</span> <span class="nf">mul</span><span class="p">(</span><span class="nf">mload</span><span class="p">(</span><span class="n">_nums</span><span class="p">),</span> <span class="mh">0x20</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// length - 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">mstore</span><span class="p">(</span><span class="n">_nums</span><span class="p">,</span> <span class="nf">sub</span><span class="p">(</span><span class="nf">mload</span><span class="p">(</span><span class="n">_nums</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">del</span><span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_nums</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">_index</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">assembly</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 下标位置需 小于 数组.length
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">if</span> <span class="nf">lt</span><span class="p">(</span><span class="n">_index</span><span class="p">,</span> <span class="nf">mload</span><span class="p">(</span><span class="n">_nums</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 将最后一个value 移到 _index 下标处 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">mstore</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">add</span><span class="p">(</span><span class="n">_nums</span><span class="p">,</span> <span class="nf">mul</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="n">_index</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mh">0x20</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                    <span class="nf">mload</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="n">_nums</span><span class="p">,</span> <span class="nf">mul</span><span class="p">(</span><span class="nf">mload</span><span class="p">(</span><span class="n">_nums</span><span class="p">),</span> <span class="mh">0x20</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">                <span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// length - 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">mstore</span><span class="p">(</span><span class="n">_nums</span><span class="p">,</span> <span class="nf">sub</span><span class="p">(</span><span class="nf">mload</span><span class="p">(</span><span class="n">_nums</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">update</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_nums</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint256</span> <span class="n">_index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint256</span> <span class="n">_num</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_nums</span><span class="p">[</span><span class="n">_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">get</span><span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_nums</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">_index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">internal</span>
</span></span><span class="line"><span class="cl">        <span class="k">pure</span>
</span></span><span class="line"><span class="cl">        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">_nums</span><span class="p">[</span><span class="n">_index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">contract</span> <span class="nc">testArr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kn">using</span> <span class="n">Array</span> <span class="k">for</span> <span class="kt">uint256</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">push</span><span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_nums</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">external</span>
</span></span><span class="line"><span class="cl">        <span class="k">pure</span>
</span></span><span class="line"><span class="cl">        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_nums</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">_nums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">pop</span><span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">external</span>
</span></span><span class="line"><span class="cl">        <span class="k">pure</span>
</span></span><span class="line"><span class="cl">        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint256</span> <span class="n">num_</span> <span class="o">=</span> <span class="n">_nums</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="n">_nums</span><span class="p">,</span> <span class="n">num_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">del</span><span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_nums</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">_index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">external</span>
</span></span><span class="line"><span class="cl">        <span class="k">pure</span>
</span></span><span class="line"><span class="cl">        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_nums</span><span class="p">.</span><span class="n">del</span><span class="p">(</span><span class="n">_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">_nums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">update</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_nums</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint256</span> <span class="n">_index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint256</span> <span class="n">_num</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="k">external</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_nums</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">_index</span><span class="p">,</span> <span class="n">_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">_nums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">get</span><span class="p">(</span><span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_nums</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">_index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">external</span>
</span></span><span class="line"><span class="cl">        <span class="k">pure</span>
</span></span><span class="line"><span class="cl">        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">_nums</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item>
<item>
  <title>OrderBook的实现思路</title>
  <link>http://blog.579878700.xyz/orderbook/</link>
  <pubDate>Wed, 15 Mar 2023 23:36:31 &#43;0800</pubDate>
  <author>map[avatar:/images/avatar.jpg email:&lt;nil&gt; link:&lt;nil&gt; name:waka]</author>
  <guid>http://blog.579878700.xyz/orderbook/</guid>
  <description><![CDATA[<h2 id="什么是orderbook">什么是OrderBook</h2>
<p><strong>OrderBook是一个包含了所有交易者信息的订单集合</strong>，他们想买或者想卖。<strong>想买的order叫做bid，想卖的order叫做ask</strong>，这些bid和ask的order一旦满足了各自的条件，就会尽可能快的完成配对，促成一笔交易。这里有两个种类的order需要介绍一下，它们也是最为基本的交易订单。<strong>第一种是市价 market order，买和卖都是依据当前在orderbook能寻找到的最优价格执行</strong>。<strong>第二种是限价 limit order，买和卖都是按照已经确定量和价格进行</strong>。OrderBook是传统金融中一个很重要的交易方式，通过OrderBook中显示的信息，可以判断当前市场的供需关系以及价格关系，基于以上的判断可以对市场中的下一步发生的变化进行一个判断。<strong>在去中心化金融(Defi)，刚开始发展时也借鉴到了OrderBook的模式</strong>，由于传统的OrderBook由中心化机构进行给出，导致了信息中心化不透明。所以在Defi中想实现一个OrderBook完全只有买方和卖方进行参与，而机构只收取相依的手续费即可。<br>
看起来这样的想法是一种很不错的想法，提供了一个更加公平和自由度更高的一个市场让人们去操作。但是在实际中进行时会发现问题：</p>
<ul>
<li><strong>对于OrderBook需求来说整个区块链网络中交易成交的速率和数量都无法满足</strong>，即使以太坊的速率相较于比特币网络有了很大的提高。</li>
<li>在交易中有gas的存在，<strong>如果没有一种很好的方法去定位到合适的订单的话，随着订单数量的变多，找到相应订单所需的gas会消耗很大</strong>。并且每笔交易都有一个gas上限，当gas达到相应上限的时候就会导致交易失败。</li>
</ul>
<h2 id="实现orderbook思路">实现OrderBook思路</h2>
<h2 id="一般的思路">一般的思路</h2>
<p>抛开以太坊特殊的条件，我们在实现OrderBook的时候，采用的最常用的方法就是蛮力法。思路：</p>
<ul>
<li>创建买单和买单两个数组</li>
<li>当有买单创建的时候，对买单数组进行遍历，找到对应价格对应数量的订单，完成一笔交易。如果没找到，将买单加入买单数组。同理创建卖单时也进行相应的操作。</li>
</ul>
<p>这个方法能确保找到所需要的的交易，但是<strong>整个过程的时间复杂度为O(n)</strong>,然后可以进行并发和互斥锁结合，可以在短时间内处理大量的买单和买单满足需求。但是随着订单量的增多，所需要的时间也会增多，这在链上和链下的环境中都是不能接受的。<br>
但是，如果不采用蛮力法的话，将<strong>买单和卖单分别用排序二叉树的方式进行数据保存，那样的话时间复杂度就会变为O(logn)</strong>，这样可以优化查找，只是在插入是有点麻烦。</p>
<h2 id="换种思路">换种思路</h2>
<p>在智能合约中我们要尽量避免时使用循环的方式，这是很费gas的。而为了确保能够得到想要的价格。我们可以这样设计：</p>
<ul>
<li>创建两个买单和卖单的两个映射
<ul>
<li><code>mapping(uint =&gt; mapping(uint =&gt; address[])) Bid;</code></li>
<li><code>mapping(uint =&gt; mapping(uint =&gt; address[])) Ask;</code></li>
<li><strong>前一个uint是价格，第二个uint是数量，最后面的是卖方或买方的地址</strong>；</li>
</ul>
</li>
<li>每次有买单和卖单进来的时候，在mapping中进行搜索，完成交易。搜索不到的话加入对应的mapping中即可。</li>
</ul>
<p>看上去这样的两个映射可以解决买卖双方的订单的查找的时间复杂度问题（<strong>将时间复杂度降为O(1)</strong>）。但是这样却忽略了一个问题，这样做我们无法看到整个市场的变化和趋势。我们这样设计代码的话只是实现了OrderBook的一部分功能。如果想要实现OrderBook，还有很多要进行修改的地方。</p>
<h2 id="第三种思路">第三种思路</h2>
<p>在链上尽量不要使用大循环，但是我们可以将大循环变为小的循环，这样来说是可以的。同时我们也要反映整个OrderBook的变化，我们就可以设计一个压缩前缀树：</p>
<ul>
<li><strong>树中的每个节点为数字0~9，这样从头结点到叶子节点前的节点就可以连成一串数字，这个数字表示金额</strong>，每个叶子节点储存的是订单数组，每个订单保存了在此金额下的数量和地址。</li>
<li>同样树也要分两颗树，买家树和卖家树。</li>
<li><strong>每次有新金额出现时，要对树进行修改</strong>，对树进行扩展，保证从头到尾连成的数字为金额。</li>
<li><strong>同时当金额对应的叶子节点中数组长度为0时，要对树进行删除</strong>，这样做的目的是保证在对树遍历时减少时间消耗。</li>
<li><strong>在新买单创建时，先在卖家树中找到对应金额的数组，在对数组进行遍历找到对应金额(此时就将大循环优化为一个小循环)</strong>，找到对应订单后就成交交易。没找到的话就将其加入买家树。(同理，卖单也是这样处理)</li>
</ul>
<p>这样的话就可以兼顾市场变化和挂单的需求。</p>
<h2 id="问题">问题</h2>
<p>以上的思路都可以实现OrderBook，但是还有许多问题需要进行考虑：</p>
<ul>
<li>如果对应的数量找不到，但是存在两个或两个以上的订单之和满足要求的时候，要怎么进行处理？<strong>在时间复杂度较小的前提下如何完成这个拆分寻找的过程？</strong></li>
<li><strong>整个树的结构要如何设计？才能使得在增删改查较为方便？</strong></li>
</ul>
<h2 id="结尾">结尾</h2>
<p>虽然现在主流的DEX没有使用OrderBook，而是使用LP这样的方式，但是LP也会存在着很多的问题需要解决。正是因为OrderBook的一些功能无法满足Defi的需求，所以才会有LP的出现。技术的适用性是需要结合需求的。或许在以后可能会产生适应区块链的OrderBook。</p>]]></description>
</item>
<item>
  <title>《Self-Sovereign Identity》(《身份自主权》中英文书籍)</title>
  <link>http://blog.579878700.xyz/ssi_book/</link>
  <pubDate>Sun, 05 Mar 2023 23:27:33 &#43;0800</pubDate>
  <author>map[avatar:/images/avatar.jpg email:&lt;nil&gt; link:&lt;nil&gt; name:waka]</author>
  <guid>http://blog.579878700.xyz/ssi_book/</guid>
  <description><![CDATA[<h2 id="百度网盘下载地址">百度网盘下载地址</h2>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1ZkE_goWKyTMtZPdyZXRp7A?pwd=b0m1"target="_blank" rel="external nofollow noopener noreferrer">https://pan.baidu.com/s/1ZkE_goWKyTMtZPdyZXRp7A?pwd=b0m1<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"></i></a>
提取码：<strong>b0m1</strong></p>
</blockquote>
<p>因为网上没有找到中文书籍，使用了deepl机翻，翻译的排版不是很好，但是基本能看懂。</p>
<h2 id="内容简介">内容简介</h2>
<p>​	Self-Sovereign Identity gives you a radical new perspective on how we represent ourselves in the world. This case study-driven book cuts through the jargon and hype to expose the amazing potential SSI offers for for security, privacy, identity, and even uprooting way the global economy works. SSI experts Drummond Reed and Alex Preukschat present a vision of the future, examining how SSI protocols will impact industries from banking through to government. You’ll get a clear mental model for how SSI works as you tour SSI-enabled eCommerce and eHealth applications and their advantages over current technologies. While you learn the philosophical and sociological concepts that underpin SSI, you’ll reach the book’s lightbulb moment: what this radical technology really means for the shape of our lives, our businesses, and our futures.</p>
<p>what&rsquo;s inside<br>
How SSI will affect your industry<br>
The essential technical and legal concepts of SSI<br>
The architecture of SSI software<br>
Emerging standards for SSI</p>
<p>​	自我主权身份 &ldquo;为您提供了一个关于我们如何在世界中代表自己的全新视角。这本以案例研究为导向的书突破了专业术语和炒作，揭示了SSI为安全、隐私、身份，甚至为全球经济运作方式提供的惊人潜力。SSI专家Drummond Reed和Alex Preukschat提出了未来的愿景，研究了SSI协议将如何影响从银行到政府的各个行业。当你参观SSI支持的电子商务和电子医疗应用以及它们相对于当前技术的优势时，你会对SSI如何工作有一个清晰的心理模型。在你学习支撑SSI的哲学和社会学概念的同时，你将迎来本书的闪光时刻：这项激进的技术对我们的生活、商业和未来的形态意味着什么。</p>
<p>书中内容<br>
SSI将如何影响你的行业<br>
SSI的基本技术和法律概念<br>
SSI软件的架构<br>
新兴的SSI标准</p>
<p></p>]]></description>
</item>
<item>
  <title>默克尔树(Merkle tree)的Go实现</title>
  <link>http://blog.579878700.xyz/merkle_tree_go/</link>
  <pubDate>Sun, 05 Mar 2023 14:09:53 &#43;0800</pubDate>
  <author>map[avatar:/images/avatar.jpg email:&lt;nil&gt; link:&lt;nil&gt; name:waka]</author>
  <guid>http://blog.579878700.xyz/merkle_tree_go/</guid>
  <description><![CDATA[<h3 id="merkle-trees">Merkle trees</h3>
<hr>
<p>Merkle树是区块链技术的基本组成部分。它是由不同数据块的散列组成的数学数据结构，用作块中所有交易的摘要。</p>
<p>它还允许对大量数据中的内容进行有效和安全的验证。此结构有助于验证数据的一致性和内容。比特币和以太坊都使用Merkle树结构。Merkle树也被称为哈希树。</p>
<p>从根本上说，Merkle树是数据结构树，其中每个叶节点都用数据块的哈希标记，非叶节点用加密标记 其子节点标签的哈希值。叶节点是树中的最低节点。</p>
<p></p>
<h3 id="原理">原理</h3>
<p>区块链中每个区块都会有一个 Merkle 树，它从叶子节点（树的底部）开始，一个叶子节点就是一个交易哈希。叶子节点的数量必须是双数，但是并非每个块都包含了双数的交易。如果一个块里面的交易数为单数，那么就将最后一个叶子节点（也就是 Merkle 树的最后一个交易，不是区块的最后一笔交易）复制一份凑成双数。</p>
<p>从下往上，两两成对，连接两个节点哈希，将组合哈希作为新的哈希。新的哈希就成为新的树节点。重复该过程，直到仅有一个节点，也就是树根。根哈希然后就会当作是整个块交易的唯一标示，将它保存到区块头，然后用于工作量证明。</p>
<hr>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;bufio&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;crypto/sha256&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//默克尔树节点结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Index</span>    <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Value</span>    <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">RootTree</span> <span class="o">*</span><span class="nx">MHTree</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//默克尔树结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">MHTree</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Length</span>   <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Nodes</span>    <span class="p">[]</span><span class="nx">Node</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rootHash</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//获得默克尔树根节点哈希值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">MHTree</span><span class="p">)</span> <span class="nf">GetRootHash</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//不管是否存储，都重新计算哈希值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nx">rootHash</span> <span class="p">=</span>   <span class="nx">t</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">getNodeHash</span><span class="p">()</span>                            
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">rootHash</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//计算默克尔树中某个节点的哈希值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="nf">getNodeHash</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//叶子节点，则直接计算该节点Value的哈希值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Value</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">calDataHash</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//非叶子节点，则递归计算哈希值,其为2个子节点哈希值的哈希值123123123123
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">calDataHash</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">RootTree</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">.</span><span class="nx">Index</span><span class="o">*</span><span class="mi">2</span><span class="p">].</span><span class="nf">getNodeHash</span><span class="p">()</span> <span class="o">+</span> <span class="nx">n</span><span class="p">.</span><span class="nx">RootTree</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">.</span><span class="nx">Index</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nf">getNodeHash</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>                                                         
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//计算数据的哈希值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">calDataHash</span><span class="p">(</span><span class="nx">data</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">sha256</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hash</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">hash</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//从结构化文件创建默克尔树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">CreateMHTree</span><span class="p">(</span><span class="nx">fileName</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">MHTree</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">tree</span> <span class="nx">MHTree</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//打开文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//获取读取器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">buf</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//读取首行，获得叶子节点数目（要求叶子节点数目为2的整数次幂
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">dataCountStr</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dataCount</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">dataCountStr</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//判断幂次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">level</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>                                          
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="mi">2</span><span class="o">&lt;&lt;</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">dataCount</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">level</span> <span class="p">=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//创建默克尔树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">//给非叶子节点赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">&lt;&lt;</span><span class="nx">level</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>                               
</span></span><span class="line"><span class="cl">		<span class="nx">tree</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Index</span> <span class="p">=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tree</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">RootTree</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">tree</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//读取文件数据，给叶子节点赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="nx">level</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">Length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>                  
</span></span><span class="line"><span class="cl">		<span class="nx">str</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tree</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Index</span> <span class="p">=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tree</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">RootTree</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">tree</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tree</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Value</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">tree</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">fileName</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;请输入原始数据文件名称&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Scanln</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fileName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mhTree1</span> <span class="o">:=</span> <span class="nf">CreateMHTree</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;请输入比对数据文件名称&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Scanln</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fileName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mhTree2</span> <span class="o">:=</span> <span class="nf">CreateMHTree</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">hash1</span> <span class="o">:=</span> <span class="nx">mhTree1</span><span class="p">.</span><span class="nf">GetRootHash</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hash2</span> <span class="o">:=</span> <span class="nx">mhTree2</span><span class="p">.</span><span class="nf">GetRootHash</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">hash1</span> <span class="o">==</span> <span class="nx">hash2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;用户没有改变数据&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;用户改变了数据&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item>
</channel>
</rss>
